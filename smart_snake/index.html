<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Playing Optimal Snake Game | Sebastian Griego</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #333;
            background-color: #f5f5f5;
        }
        
        .container {
            width: 80%;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 40px 0;
            background-color: #2c3e50;
            color: #ecf0f1;
        }
        
        h1 {
            margin: 0;
            font-size: 2.5rem;
        }
        
        .tagline {
            font-style: italic;
            margin-top: 10px;
        }
        
        section {
            background-color: white;
            padding: 30px;
            margin: 20px 0;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        h2 {
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 30px;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        
        /* Game specific styles */
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        canvas {
            border: 2px solid #2c3e50;
            background-color: #ecf0f1;
            max-width: 100%;
        }
        
        #stats {
            margin-top: 15px;
            font-size: 18px;
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 400px;
        }
        
        .stat-box {
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            flex: 1;
            margin: 0 5px;
        }
        
        .stat-box span {
            font-weight: bold;
            color: #3498db;
        }
        
        #controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 8px 15px;
            border: none;
            background-color: #3498db;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        #speed-control {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        
        #speed-control label {
            margin-right: 10px;
        }
        
        #speed-slider {
            width: 200px;
        }
        
        .method-box {
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        
        .method-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .back-link {
            display: inline-block;
            margin-top: 20px;
            padding: 8px 15px;
            background-color: #3498db;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        
        .back-link:hover {
            background-color: #2980b9;
        }
        
        @media (max-width: 600px) {
            .container {
                width: 95%;
            }
            
            canvas {
                width: 100%;
                height: auto;
            }
            
            #stats {
                flex-direction: column;
                gap: 5px;
            }
            
            #controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Self-Playing Snake Game</h1>
            <p class="tagline">Optimal AI pathfinding algorithm</p>
        </div>
    </header>
    
    <div class="container">
        <section>
            <h2>About This Project</h2>
            <p>
                This self-playing snake game uses a combination of Hamiltonian cycle pathfinding with shortcuts to achieve optimal results. 
                The AI automatically navigates the snake to collect food while avoiding collisions with walls and itself, 
                even when the snake grows to fill most of the game board.
            </p>
            <p>
                Click the "Start" button to watch the AI in action, and use the speed slider to adjust how fast it plays.
            </p>
        </section>
        
        <section>
            <h2>Game</h2>
            <div id="game-container">
                <canvas id="gameCanvas" width="400" height="400"></canvas>
                <div id="stats">
                    <div class="stat-box">Score: <span id="score">0</span></div>
                    <div class="stat-box">Length: <span id="length">1</span></div>
                    <div class="stat-box">Max: <span id="max-score">0</span></div>
                </div>
                <div id="speed-control">
                    <label for="speed-slider">Speed:</label>
                    <input type="range" id="speed-slider" min="1" max="100" value="20">
                </div>
                <div id="controls">
                    <button id="start-btn">Start</button>
                    <button id="pause-btn">Pause</button>
                    <button id="reset-btn">Reset</button>
                </div>
                <div class="method-box">
                    <div class="method-title">Current Method:</div>
                    <div id="current-method">Hamiltonian Cycle with Shortcuts</div>
                </div>
            </div>
            <a href="../index.html" class="back-link">← Back to Projects</a>
        </section>
        
        <section>
            <h2>How It Works</h2>
            <p>
                The algorithm uses two main techniques:
            </p>
            <ul>
                <li><strong>Hamiltonian Cycle:</strong> A path that visits every cell exactly once and returns to the start, ensuring the snake will never trap itself.</li>
                <li><strong>Shortcut Optimization:</strong> When it's safe, the AI takes shortcuts to reach food faster while avoiding potential collisions.</li>
            </ul>
            <p>
                This combination allows the snake to achieve the highest possible score while maintaining perfect safety.
            </p>
        </section>
    </div>
    
    <footer>
        <div class="container">
            <p>&copy; 2025 Sebastian Griego. All rights reserved.</p>
        </div>
    </footer>

    <script>
        // Game Configuration
        const config = {
            gridSize: 20,      // Grid is 20x20
            cellSize: 20,      // Each cell is 20x20 pixels
            initialSpeed: 20,  // Initial frames per second
            maxSpeed: 100      // Maximum speed limit
        };
        
        // Game State
        const game = {
            canvas: null,
            ctx: null,
            snake: [],         // Array of coordinates for snake segments
            direction: 'right',
            pendingDirection: 'right',
            food: { x: 0, y: 0 },
            score: 0,
            maxScore: 0,
            isRunning: false,
            isPaused: false,
            frameCount: 0,
            speed: config.initialSpeed,
            hamCycle: [],      // Will store the Hamiltonian cycle path
            lastTime: 0,
            deltaTime: 0
        };

        // Render game state to canvas
        function render() {
            // Clear canvas
            game.ctx.clearRect(0, 0, game.canvas.width, game.canvas.height);
            
            // Draw grid (optional - for debugging)
            drawGrid();
            
            // Draw food
            drawFood();
            
            // Draw snake();
            drawSnake();
        }

        // Draw the grid
        function drawGrid() {
            game.ctx.strokeStyle = '#e0e0e0';
            game.ctx.lineWidth = 0.5;
            
            // Draw vertical lines
            for (let x = 0; x <= config.gridSize; x++) {
                game.ctx.beginPath();
                game.ctx.moveTo(posToCoord(x), 0);
                game.ctx.lineTo(posToCoord(x), game.canvas.height);
                game.ctx.stroke();
            }
            
            // Draw horizontal lines
            for (let y = 0; y <= config.gridSize; y++) {
                game.ctx.beginPath();
                game.ctx.moveTo(0, posToCoord(y));
                game.ctx.lineTo(game.canvas.width, posToCoord(y));
                game.ctx.stroke();
            }
        }

        // Draw the food
        function drawFood() {
            game.ctx.fillStyle = '#e74c3c';
            
            // Draw apple-like shape
            game.ctx.beginPath();
            game.ctx.arc(
                posToCoord(game.food.x) + config.cellSize / 2,
                posToCoord(game.food.y) + config.cellSize / 2,
                config.cellSize / 2 - 2,
                0,
                Math.PI * 2
            );
            game.ctx.fill();
            
            // Add apple stem
            game.ctx.fillStyle = '#7B5E57';
            game.ctx.fillRect(
                posToCoord(game.food.x) + config.cellSize / 2 - 1,
                posToCoord(game.food.y) + 2,
                2,
                4
            );
        }

        // Draw the snake
        function drawSnake() {
            // Draw snake body
            for (let i = game.snake.length - 1; i >= 0; i--) {
                const segment = game.snake[i];
                
                // Calculate color gradient from tail to head
                const blueValue = Math.floor(140 + (100 * (i / game.snake.length)));
                game.ctx.fillStyle = `rgb(52, ${blueValue}, 235)`;
                
                // Draw rounded rectangle for each segment
                drawRoundedRect(
                    posToCoord(segment.x) + 1,
                    posToCoord(segment.y) + 1,
                    config.cellSize - 2,
                    config.cellSize - 2,
                    4 // Border radius
                );
                
                // Draw eyes on the head
                if (i === 0) {
                    game.ctx.fillStyle = 'white';
                    
                    // Position eyes based on direction
                    let leftEyeX, leftEyeY, rightEyeX, rightEyeY;
                    const eyeSize = 3;
                    const eyeOffset = 4;
                    
                    switch (game.direction) {
                        case 'up':
                            leftEyeX = posToCoord(segment.x) + eyeOffset;
                            leftEyeY = posToCoord(segment.y) + eyeOffset;
                            rightEyeX = posToCoord(segment.x) + config.cellSize - eyeOffset - eyeSize;
                            rightEyeY = posToCoord(segment.y) + eyeOffset;
                            break;
                        case 'down':
                            leftEyeX = posToCoord(segment.x) + eyeOffset;
                            leftEyeY = posToCoord(segment.y) + config.cellSize - eyeOffset - eyeSize;
                            rightEyeX = posToCoord(segment.x) + config.cellSize - eyeOffset - eyeSize;
                            rightEyeY = posToCoord(segment.y) + config.cellSize - eyeOffset - eyeSize;
                            break;
                        case 'left':
                            leftEyeX = posToCoord(segment.x) + eyeOffset;
                            leftEyeY = posToCoord(segment.y) + eyeOffset;
                            rightEyeX = posToCoord(segment.x) + eyeOffset;
                            rightEyeY = posToCoord(segment.y) + config.cellSize - eyeOffset - eyeSize;
                            break;
                        case 'right':
                            leftEyeX = posToCoord(segment.x) + config.cellSize - eyeOffset - eyeSize;
                            leftEyeY = posToCoord(segment.y) + eyeOffset;
                            rightEyeX = posToCoord(segment.x) + config.cellSize - eyeOffset - eyeSize;
                            rightEyeY = posToCoord(segment.y) + config.cellSize - eyeOffset - eyeSize;
                            break;
                    }
                    
                    // Draw eyes
                    game.ctx.fillRect(leftEyeX, leftEyeY, eyeSize, eyeSize);
                    game.ctx.fillRect(rightEyeX, rightEyeY, eyeSize, eyeSize);
                }
            }
        }

        // Helper function to draw rounded rectangles
        function drawRoundedRect(x, y, width, height, radius) {
            game.ctx.beginPath();
            game.ctx.moveTo(x + radius, y);
            game.ctx.lineTo(x + width - radius, y);
            game.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            game.ctx.lineTo(x + width, y + height - radius);
            game.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            game.ctx.lineTo(x + radius, y + height);
            game.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            game.ctx.lineTo(x, y + radius);
            game.ctx.quadraticCurveTo(x, y, x + radius, y);
            game.ctx.closePath();
            game.ctx.fill();
        }

        // Update score and stats display
        function updateStats() {
            document.getElementById('score').textContent = game.score;
            document.getElementById('length').textContent = game.snake.length;
            document.getElementById('max-score').textContent = game.maxScore;
        }

        // Initialize the game
        function init() {
            // Get the canvas and its context
            game.canvas = document.getElementById('gameCanvas');
            game.ctx = game.canvas.getContext('2d');
            
            // Initialize the snake at the center of the grid
            const centerX = Math.floor(config.gridSize / 2);
            const centerY = Math.floor(config.gridSize / 2);
            game.snake = [{ x: centerX, y: centerY }];
            
            // Generate initial food position
            placeFood();
            
            // Generate the Hamiltonian cycle path for optimal play
            generateHamiltonianCycle();
            
            // Set up event handlers
            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('pause-btn').addEventListener('click', pauseGame);
            document.getElementById('reset-btn').addEventListener('click', resetGame);
            document.getElementById('speed-slider').addEventListener('input', updateSpeed);
            
            // Make sure the canvas is responsive
            window.addEventListener('resize', adjustCanvasSize);
            adjustCanvasSize();
            
            // Initial render
            render();
        }
        
        // Adjust canvas size for responsiveness
        function adjustCanvasSize() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth;
            
            if (containerWidth < game.canvas.width) {
                const scale = containerWidth / game.canvas.width;
                game.canvas.style.width = `${containerWidth}px`;
                game.canvas.style.height = `${game.canvas.height * scale}px`;
            } else {
                game.canvas.style.width = '';
                game.canvas.style.height = '';
            }
        }
        
        // Generate Hamiltonian cycle using a row-wise pattern with vertical return lane
        function generateHamiltonianCycle() {
            const n = config.gridSize;
            let cycle = [];
            // Build a basic zigzag ordering row-wise.
            for (let y = 0; y < n; y++) {
                if (y % 2 === 0) {
                    for (let x = 0; x < n; x++) {
                        cycle.push({ x, y });
                    }
                } else {
                    for (let x = n - 1; x >= 0; x--) {
                        cycle.push({ x, y });
                    }
                }
            }
            
            // Rotate the ordering so that the end and beginning are neighbors.
            for (let r = 0; r < cycle.length; r++) {
                const rotated = cycle.slice(r).concat(cycle.slice(0, r));
                const first = rotated[0];
                const last = rotated[rotated.length - 1];
                // They’re adjacent (neighbors) if the Manhattan distance is 1.
                if (Math.abs(first.x - last.x) + Math.abs(first.y - last.y) === 1) {
                    game.hamCycle = rotated;
                    return;
                }
            }
            
            // Fallback (should not happen).  
            game.hamCycle = cycle;
        }
        // Place food at random unoccupied location
        function placeFood() {
            let validPosition = false;
            while (!validPosition) {
                const x = Math.floor(Math.random() * config.gridSize);
                const y = Math.floor(Math.random() * config.gridSize);
                
                // Check if position is occupied by snake
                validPosition = !game.snake.some(segment => segment.x === x && segment.y === y);
                
                if (validPosition) {
                    game.food = { x, y };
                }
            }
        }
        
        // Start game loop
        function startGame() {
            if (!game.isRunning) {
                game.isRunning = true;
                game.isPaused = false;
                game.lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            } else if (game.isPaused) {
                game.isPaused = false;
                game.lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        }
        
        // Pause the game
        function pauseGame() {
            game.isPaused = !game.isPaused;
            if (!game.isPaused && game.isRunning) {
                game.lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        }
        
        // Reset the game
        function resetGame() {
            game.isRunning = false;
            game.isPaused = false;
            
            // Reset snake
            const centerX = Math.floor(config.gridSize / 2);
            const centerY = Math.floor(config.gridSize / 2);
            game.snake = [{ x: centerX, y: centerY }];
            
            // Reset direction
            game.direction = 'right';
            game.pendingDirection = 'right';
            
            // Reset score
            game.score = 0;
            updateStats();
            
            // Place new food
            placeFood();
            
            // Render the new state
            render();
        }
        
        // Update game speed from slider
        function updateSpeed() {
            const speedSlider = document.getElementById('speed-slider');
            game.speed = parseInt(speedSlider.value);
        }
        
        // Convert position in grid to coordinates on canvas
        function posToCoord(pos) {
            return pos * config.cellSize;
        }
        
        // Main game loop
        function gameLoop(timestamp) {
            if (!game.isRunning || game.isPaused) {
                return;
            }
            
            // Calculate delta time for consistent speed regardless of frame rate
            game.deltaTime = timestamp - game.lastTime;
            
            // Determine if it's time to update game state based on speed
            if (game.deltaTime >= 1000 / game.speed) {
                game.lastTime = timestamp;
                
                // Update game state (AI moves the snake)
                update();
                
                // Render the new state
                render();
            }
            
            // Continue the loop
            requestAnimationFrame(gameLoop);
        }
        
        // Update game state (move snake, check collisions, etc.)
        function update() {
            // Get AI's next move
            const nextDirection = getOptimalMove();
            game.direction = nextDirection;

            // Calculate new head position based on current direction
            const head = { ...game.snake[0] }; // Copy the head

            switch (game.direction) {
                case 'up':
                    head.y -= 1;
                    break;
                case 'down':
                    head.y += 1;
                    break;
                case 'left':
                    head.x -= 1;
                    break;
                case 'right':
                    head.x += 1;
                    break;
            }

            // Check for collisions with walls
            if (head.x < 0 || head.x >= config.gridSize || head.y < 0 || head.y >= config.gridSize) {
                // Game over - hit wall
                game.isRunning = false;
                return;
            }

            // Check for collisions with self (excluding tail if it will move)
            const willEatFood = (head.x === game.food.x && head.y === game.food.y);
            const tailIndex = game.snake.length - 1;

            for (let i = 0; i < game.snake.length; i++) {
                // Skip the tail check if the snake isn't about to eat food (tail will move)
                if (i === tailIndex && !willEatFood) {
                    continue;
                }

                if (head.x === game.snake[i].x && head.y === game.snake[i].y) {
                    // Game over - collision with self
                    game.isRunning = false;
                    return;
                }
            }

            // Add new head
            game.snake.unshift(head);

            // Check if food is eaten
            if (head.x === game.food.x && head.y === game.food.y) {
                // Increase score
                game.score++;
                game.maxScore = Math.max(game.score, game.maxScore);
                updateStats();

                // Place new food
                placeFood();
            } else {
                // Remove tail (snake didn't grow)
                game.snake.pop();
            }
        }

       // Helper function to check if moving in a given direction is safe.
function isSafeMove(direction) {
    const head = game.snake[0];
    let newHead = { ...head };
    if (direction === 'up') newHead.y--;
    else if (direction === 'down') newHead.y++;
    else if (direction === 'left') newHead.x--;
    else if (direction === 'right') newHead.x++;
    
    // Check boundaries
    if (newHead.x < 0 || newHead.x >= config.gridSize ||
        newHead.y < 0 || newHead.y >= config.gridSize) {
        return false;
    }
    
    // Determine if the snake is about to eat food (tail does not move in that case)
    const willEatFood = (newHead.x === game.food.x && newHead.y === game.food.y);
    const tailIndex = game.snake.length - 1;
    
    // Check collision with snake's body (skip tail check if not eating)
    for (let i = 0; i < game.snake.length; i++) {
        if (i === tailIndex && !willEatFood) continue;
        if (newHead.x === game.snake[i].x && newHead.y === game.snake[i].y) {
            return false;
        }
    }
    return true;
}

// Compute the accessible area from a given cell using a flood-fill algorithm.
function accessibleAreaFrom(start) {
    const visited = {};
    let count = 0;
    const queue = [start];

    // Helper to create a unique key for each cell
    function cellKey(cell) {
        return `${cell.x},${cell.y}`;
    }

    while (queue.length > 0) {
        const cell = queue.shift();
        const key = cellKey(cell);
        if (visited[key]) continue;
        visited[key] = true;
        count++;

        const neighbors = [
            {x: cell.x - 1, y: cell.y},
            {x: cell.x + 1, y: cell.y},
            {x: cell.x, y: cell.y - 1},
            {x: cell.x, y: cell.y + 1},
        ];

        for (const neighbor of neighbors) {
            // Skip out-of-bounds neighbors
            if (neighbor.x < 0 || neighbor.x >= config.gridSize ||
                neighbor.y < 0 || neighbor.y >= config.gridSize) {
                continue;
            }
            
            // Skip cells occupied by the snake
            let blocked = false;
            for (const seg of game.snake) {
                if (seg.x === neighbor.x && seg.y === neighbor.y) {
                    blocked = true;
                    break;
                }
            }
            if (blocked) continue;
            
            if (!visited[cellKey(neighbor)]) {
                queue.push(neighbor);
            }
        }
    }

    return count;
}

// The getOptimalMove function now checks if the chosen move is safe.
function getOptimalMove() {
    // Find the food's and snake head's positions in the Hamiltonian cycle
    const foodIndex = game.hamCycle.findIndex(pos => 
        pos.x === game.food.x && pos.y === game.food.y
    );
    const headIndex = game.hamCycle.findIndex(pos => 
        pos.x === game.snake[0].x && pos.y === game.snake[0].y
    );
    
    // Define opposite directions for 180-degree turn prevention
    const oppositeDirections = {
        'up': 'down',
        'down': 'up',
        'left': 'right',
        'right': 'left'
    };
    
    // Determine the default move by following the Hamiltonian cycle
    const nextIndex = (headIndex + 1) % game.hamCycle.length;
    const nextPos = game.hamCycle[nextIndex];
    
    // Try to use a shortcut if safe and if the snake is relatively short
    if (game.snake.length < (config.gridSize * config.gridSize * 0.8) && 
        isSafeToShortcut(headIndex, foodIndex)) {
            
        const shortcutDir = getShortcutDirection();
        // Only use the shortcut if it's not a 180-degree turn
        if (shortcutDir !== oppositeDirections[game.direction] &&
             isSafeMove(shortcutDir)) {
            return shortcutDir;
        }
    }
    
    // Determine default direction based on the Hamiltonian cycle adjacency
    let defaultDir;
    if (nextPos.x > game.snake[0].x) defaultDir = 'right';
    else if (nextPos.x < game.snake[0].x) defaultDir = 'left';
    else if (nextPos.y > game.snake[0].y) defaultDir = 'down';
    else if (nextPos.y < game.snake[0].y) defaultDir = 'up';
    
    // Prevent a 180-degree turn by continuing the current direction if needed
    if (defaultDir === oppositeDirections[game.direction]) {
        defaultDir = game.direction;
    }
    
    // Check if following defaultDir is safe before returning it
    if (!isSafeMove(defaultDir)) {
        // If not safe, try alternate directions
        const tryDirs = ['up', 'right', 'down', 'left'];
        for (let dir of tryDirs) {
            if (dir === oppositeDirections[game.direction]) continue; // avoid 180° turns
            if (isSafeMove(dir)) {
                return dir;
            }
        }
        // If no alternative is found, stick with the current direction as a fallback.
        return game.direction;
    }
    
    return defaultDir;
}

// Check if it's safe to take a shortcut from current position
function isSafeToShortcut(headIndex, foodIndex) {
    // More conservative threshold for longer snakes
    if (game.snake.length > config.gridSize * config.gridSize * 0.4) {
        return false;
    }
    
    // Calculate distance to food along Hamiltonian cycle
    let distAlongCycle;
    if (foodIndex >= headIndex) {
        distAlongCycle = foodIndex - headIndex;
    } else {
        distAlongCycle = (game.hamCycle.length - headIndex) + foodIndex;
    }
    
    // Only consider shortcuts if food is more than 10 steps away on the cycle
    if (distAlongCycle <= 15) {
        return false;
    }

    // Check if there's enough space around the snake head
    if (!hasEnoughSpace()) {
        return false;
    }

    // Check if there's a path to the food
    const path = findPathBFS(game.snake[0], game.food);
    
    // If no path was found, it's not safe
    if (!path || path.length < 2) {
        return false;
    }

    // Simulate the snake moving along the path to check for safety
    let simulatedSnake = [...game.snake.map(seg => ({...seg}))];
    
    // Only check the first 5 steps of the path (for performance)
    const pathSteps = Math.min(path.length, 5);
    
    for (let i = 1; i < pathSteps; i++) {
        const nextMove = path[i];
        
        // Move the simulated snake
        simulatedSnake.unshift({x: nextMove.x, y: nextMove.y});
        
        // If it didn't eat food at this position, remove the tail
        const ateFoodInSimulation = nextMove.x === game.food.x && nextMove.y === game.food.y;
        if (!ateFoodInSimulation) {
            simulatedSnake.pop();
        }
        
        // Check for self-collisions in the simulated snake
        const head = simulatedSnake[0];
        for (let j = 1; j < simulatedSnake.length; j++) {
            if (head.x === simulatedSnake[j].x && head.y === simulatedSnake[j].y) {
                return false; // Collision detected
            }
        }
    }

    // If simulation completed without collisions, the shortcut is safe
    return true;
}

// Helper function to check if there's enough space around the snake's head
function hasEnoughSpace() {
    const head = game.snake[0];
    let openSpaces = 0;
    const directions = [
        {x: 0, y: -1}, // up
        {x: 1, y: 0},  // right
        {x: 0, y: 1},  // down
        {x: -1, y: 0}  // left
    ];
    
    // Check each adjacent cell
    for (const dir of directions) {
        const x = head.x + dir.x;
        const y = head.y + dir.y;
        
        // Skip if out of bounds
        if (x < 0 || x >= config.gridSize || y < 0 || y >= config.gridSize) {
            continue;
        }
        
        // Check if cell is occupied by snake body (excluding tail if it will move)
        let cellOccupied = false;
        const tailIndex = game.snake.length - 1;
        
        for (let i = 1; i < game.snake.length; i++) { // Start at 1 to skip head
            if (i === tailIndex && game.food.x !== head.x && game.food.y !== head.y) {
                // Skip tail check if snake isn't about to eat food
                continue;
            }
            
            if (x === game.snake[i].x && y === game.snake[i].y) {
                cellOccupied = true;
                break;
            }
        }
        
        if (!cellOccupied) {
            openSpaces++;
        }
    }
    
    // If there's only one open space, be more cautious
    return openSpaces >= 2;
}

// Get the direction for a shortcut to food
function getShortcutDirection() {
    // Get the current head position
    const head = game.snake[0];

    // Define opposite directions
    const oppositeDirections = {
        'up': 'down',
        'down': 'up',
        'left': 'right',
        'right': 'left'
    };
    
    // Get path to food using BFS
    const path = findPathBFS(head, game.food);
    
    // If no path was found, follow Hamiltonian cycle
    if (!path || path.length < 2) {
        const headIndex = game.hamCycle.findIndex(pos => 
            pos.x === head.x && pos.y === head.y
        );
        const nextIndex = (headIndex + 1) % game.hamCycle.length;
        const nextPos = game.hamCycle[nextIndex];
        
        if (nextPos.x > head.x) return 'right';
        if (nextPos.x < head.x) return 'left';
        if (nextPos.y > head.y) return 'down';
        if (nextPos.y < head.y) return 'up';
        
        return game.direction;
    }
    
    // Get the next move from the path
    const nextMove = path[1]; // path[0] is the current head position
    
    // Determine direction to next position
    let nextDirection;
    if (nextMove.x > head.x) nextDirection = 'right';
    else if (nextMove.x < head.x) nextDirection = 'left';
    else if (nextMove.y > head.y) nextDirection = 'down';
    else if (nextMove.y < head.y) nextDirection = 'up';
    else nextDirection = game.direction;
    
    // IMPORTANT: Verify that we're not making a 180-degree turn
    if (nextDirection === oppositeDirections[game.direction]) {
        // Fall back to the Hamiltonian cycle
        const headIndex = game.hamCycle.findIndex(pos => 
            pos.x === head.x && pos.y === head.y
        );
        const nextIndex = (headIndex + 1) % game.hamCycle.length;
        const nextPos = game.hamCycle[nextIndex];
        
        if (nextPos.x > head.x) return 'right';
        if (nextPos.x < head.x) return 'left';
        if (nextPos.y > head.y) return 'down';
        if (nextPos.y < head.y) return 'up';
        
        return game.direction;
    }
    
    // Check if this move might create a trap
    if (willCreateTrap(nextMove.x, nextMove.y)) {
        // Fall back to the Hamiltonian cycle
        const headIndex = game.hamCycle.findIndex(pos => 
            pos.x === head.x && pos.y === head.y
        );
        const nextIndex = (headIndex + 1) % game.hamCycle.length;
        const nextPos = game.hamCycle[nextIndex];
        
        if (nextPos.x > head.x) return 'right';
        if (nextPos.x < head.x) return 'left';
        if (nextPos.y > head.y) return 'down';
        if (nextPos.y < head.y) return 'up';
        
        return game.direction;
    }
    
    return nextDirection;
}

// Helper function to check if a move will create a trap
function willCreateTrap(nextX, nextY) {
    // Check how many open spaces would be available after the move
    const directions = [
        {x: 0, y: -1}, // up
        {x: 1, y: 0},  // right
        {x: 0, y: 1},  // down
        {x: -1, y: 0}  // left
    ];
    
    let openSpaces = 0;
    
    // Create a simulated snake for checking
    let simulatedSnake = [...game.snake.map(seg => ({...seg}))];
    simulatedSnake.unshift({x: nextX, y: nextY});
    simulatedSnake.pop(); // Remove tail
    
    for (const dir of directions) {
        const x = nextX + dir.x;
        const y = nextY + dir.y;
        
        // Skip if out of bounds
        if (x < 0 || x >= config.gridSize || y < 0 || y >= config.gridSize) {
            continue;
        }
        
        // Check if this space is occupied by the simulated snake
        let isOccupied = false;
        for (let i = 1; i < simulatedSnake.length; i++) { // Skip the head
            if (simulatedSnake[i].x === x && simulatedSnake[i].y === y) {
                isOccupied = true;
                break;
            }
        }
        
        if (!isOccupied) {
            openSpaces++;
        }
    }
    
    // If there's only one or zero open spaces, it's a potential trap
    return openSpaces <= 1;
}

// BFS pathfinding algorithm
function findPathBFS(start, target) {
    const queue = [];
    const visited = {};
    const parent = {};
    
    // Add start position to queue
    queue.push({x: start.x, y: start.y});
    visited[`${start.x},${start.y}`] = true;
    
    while (queue.length > 0) {
        const current = queue.shift();
        
        // Found target
        if (current.x === target.x && current.y === target.y) {
            // Reconstruct path
            const path = [];
            let curr = current;
            
            while (curr) {
                path.unshift(curr);
                curr = parent[`${curr.x},${curr.y}`];
            }
            
            return path;
        }
        
        // Check all four directions
        const directions = [
            {x: 0, y: -1}, // up
            {x: 1, y: 0},  // right
            {x: 0, y: 1},  // down
            {x: -1, y: 0}  // left
        ];
        
        // Sort directions by distance to target
        directions.sort((a, b) => {
            const aDist = Math.abs((current.x + a.x) - target.x) + Math.abs((current.y + a.y) - target.y);
            const bDist = Math.abs((current.x + b.x) - target.x) + Math.abs((current.y + b.y) - target.y);
            return aDist - bDist;
        });
        
        for (const dir of directions) {
            const x = current.x + dir.x;
            const y = current.y + dir.y;
            const key = `${x},${y}`;
            
            // Skip if out of bounds
            if (x < 0 || x >= config.gridSize || y < 0 || y >= config.gridSize) {
                continue;
            }
            
            // Skip if already visited
            if (visited[key]) {
                continue;
            }
            
            // Skip if occupied by snake
            let cellOccupied = false;
            const tailIndex = game.snake.length - 1;
            for (let i = 0; i < game.snake.length; i++) {
                // Skip tail check if not about to eat
                if (i === tailIndex && !(x === game.food.x && y === game.food.y)) {
                    continue;
                }
                if (x === game.snake[i].x && y === game.snake[i].y) {
                    cellOccupied = true;
                    break;
                }
            }
            
            if (cellOccupied) {
                continue;
            }
            
            // Add to queue and mark as visited
            queue.push({ x, y });
            visited[key] = true;
            parent[key] = current;
        }
    }
    // No path found
    return null;
}

// Global event listener to initialize the game when the window loads
window.addEventListener('load', init);
    </script>
</body>
</html>