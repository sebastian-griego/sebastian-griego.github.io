<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verbal Assassins - Multiplayer</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for better aesthetics in dark mode */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b;
        }
        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
        /* Simple animation for elements fading in */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-200 antialiased">

    <div id="app" class="container mx-auto p-4 md:p-8 max-w-7xl">

        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-extrabold bg-gradient-to-r from-rose-400 via-fuchsia-500 to-indigo-500 bg-clip-text text-transparent pb-2">
                Verbal Assassins
            </h1>
            <p class="text-slate-400">A real-time multiplayer assassination game for our group.</p>
            <div id="user-info" class="mt-4 text-xs text-slate-500 bg-slate-800 rounded-md p-2 inline-block">
                Connecting...
            </div>
        </header>

        <!-- Loading State -->
        <div id="loading" class="text-center py-10">
            <p class="text-lg text-slate-400">Loading Game State...</p>
        </div>

        <!-- Game Content (hidden until loaded) -->
        <main id="game-content" class="hidden">
            <!-- Controls -->
            <div id="controls" class="flex flex-wrap justify-center gap-3 mb-8 fade-in">
                <button id="shuffle-btn" class="bg-green-600 hover:bg-green-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">ðŸ”€ Shuffle Cycle</button>
                <button id="kill-btn" class="bg-rose-600 hover:bg-rose-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">ðŸ’€ Record Kill</button>
                <button id="word-btn" class="bg-amber-500 hover:bg-amber-400 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">ðŸŽ² New Word</button>
                <button id="reset-btn" class="bg-slate-600 hover:bg-slate-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">ðŸ”„ Reset Game</button>
            </div>
            
            <!-- Stats -->
            <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-8 fade-in">
                <div class="bg-slate-800 p-4 rounded-xl text-center shadow-lg"><div id="players-alive" class="text-3xl font-bold text-green-400">0</div><div class="text-slate-400">Players Alive</div></div>
                <div class="bg-slate-800 p-4 rounded-xl text-center shadow-lg"><div id="players-dead" class="text-3xl font-bold text-rose-400">0</div><div class="text-slate-400">Eliminated</div></div>
                <div class="bg-slate-800 p-4 rounded-xl text-center shadow-lg"><div id="total-kills" class="text-3xl font-bold text-sky-400">0</div><div class="text-slate-400">Total Kills</div></div>
            </div>

            <!-- Main Grid -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Players Section -->
                <div class="lg:col-span-2 bg-slate-800 p-6 rounded-xl shadow-lg fade-in">
                    <h2 class="text-2xl font-bold mb-4 text-sky-400">Player Roster</h2>
                    <div id="player-list" class="space-y-3"></div>
                </div>
                <!-- Kill History Section -->
                <div class="bg-slate-800 p-6 rounded-xl shadow-lg fade-in">
                    <h2 class="text-2xl font-bold mb-4 text-rose-400">Kill History</h2>
                    <div id="kill-history" class="space-y-3 max-h-[60vh] overflow-y-auto pr-2"></div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modals -->
    <div id="modal-container" class="fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center p-4 hidden">
        <div id="modal-content" class="bg-slate-800 rounded-xl shadow-2xl p-6 w-full max-w-md fade-in">
            <!-- Modal content will be injected here -->
        </div>
    </div>
    
    <!-- Firebase SDKs -->
    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL VARIABLES & CONFIG ---

        // These variables are provided by the environment. Do not change them.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-verbal-assassins';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Firebase services
        let app, db, auth;
        let userId = null;
        let gameUnsubscribe = null; // To detach the listener later

        // Game state (local cache, always updated by Firestore)
        let gameState = {};
        let commonWords = []; // Will be populated from CSV

        // DOM Elements
        const loadingEl = document.getElementById('loading');
        const gameContentEl = document.getElementById('game-content');
        const userInfoEl = document.getElementById('user-info');
        const modalContainer = document.getElementById('modal-container');
        const modalContent = document.getElementById('modal-content');

        // --- INITIALIZATION ---

        async function main() {
            // Load words from CSV before doing anything else
            await loadWordList(); 

            try {
                // Initialize Firebase
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Listen for authentication state changes
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        userInfoEl.innerHTML = `Your User ID: <span class="font-mono text-sky-400">${userId}</span>`;
                        connectToGame();
                    } else {
                        userId = null;
                        userInfoEl.textContent = "Not signed in.";
                        if (gameUnsubscribe) gameUnsubscribe();
                    }
                });

                // Sign in the user
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                loadingEl.textContent = "Error: Could not connect to the game service.";
            }
        }
        
        // --- FIRESTORE REAL-TIME CONNECTION ---

        function connectToGame() {
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, "verbal-assassins-game-specific");

            gameUnsubscribe = onSnapshot(gameDocRef, (docSnap) => {
                loadingEl.classList.add('hidden');
                gameContentEl.classList.remove('hidden');

                if (docSnap.exists()) {
                    gameState = docSnap.data();
                } else {
                    // If the document doesn't exist, create the initial game state
                    gameState = getInitialGameState();
                    setDoc(gameDocRef, gameState);
                }
                
                updateDisplay();
            }, (error) => {
                console.error("Error listening to game state:", error);
                loadingEl.textContent = "Error: Lost connection to the game.";
            });
        }

        // --- UI UPDATE FUNCTION ---

        function updateDisplay() {
            if (!gameState) return;

            // Update stats
            const alivePlayers = gameState.players ? gameState.players.filter(p => p.alive) : [];
            document.getElementById('players-alive').textContent = alivePlayers.length;
            document.getElementById('players-dead').textContent = (gameState.players?.length || 0) - alivePlayers.length;
            document.getElementById('total-kills').textContent = gameState.killHistory?.length || 0;

            // Update player list
            const playerList = document.getElementById('player-list');
            playerList.innerHTML = '';
            if (gameState.players && gameState.players.length > 0) {
                // Sort players: alive first, then alphabetically
                const sortedPlayers = [...gameState.players].sort((a, b) => {
                    if (a.alive && !b.alive) return -1;
                    if (!a.alive && b.alive) return 1;
                    return a.name.localeCompare(b.name);
                });

                sortedPlayers.forEach(player => {
                    const playerCard = document.createElement('div');
                    playerCard.className = `p-4 rounded-lg grid grid-cols-1 md:grid-cols-3 gap-4 items-center transition-all duration-300 ${player.alive ? 'bg-slate-700' : 'bg-slate-800/50 opacity-50'}`;
                    
                    const targetInfo = player.target || 'N/A';
                    const wordInfo = player.word || 'N/A';

                    playerCard.innerHTML = `
                        <div class="font-bold text-lg ${player.alive ? 'text-white' : 'text-slate-500 line-through'}">${player.name}</div>
                        <div class="text-slate-400">Target: <span class="font-semibold text-rose-400">${targetInfo}</span></div>
                        <div class="text-slate-400">Word: <span class="font-mono bg-slate-600 px-2 py-1 rounded text-amber-300">${wordInfo}</span></div>
                    `;
                    playerList.appendChild(playerCard);
                });
            } else {
                playerList.innerHTML = `<p class="text-slate-500 text-center py-4">Game not initialized. Click Reset Game.</p>`;
            }

            // Update kill history
            const killHistoryEl = document.getElementById('kill-history');
            killHistoryEl.innerHTML = '';
            if (gameState.killHistory && gameState.killHistory.length > 0) {
                [...gameState.killHistory].reverse().forEach(kill => {
                    const killEntry = document.createElement('div');
                    killEntry.className = 'bg-slate-700/50 p-3 rounded-lg';
                    killEntry.innerHTML = `
                        <div>
                            <span class="font-bold text-rose-400">${kill.killer}</span> eliminated <span class="font-bold text-slate-400">${kill.victim}</span>
                        </div>
                        <div class="text-xs text-slate-500 mt-1">Word: <span class="font-mono">${kill.word}</span> at ${kill.timestamp}</div>
                    `;
                    killHistoryEl.appendChild(killEntry);
                });
            } else {
                killHistoryEl.innerHTML = `<p class="text-slate-500 text-center py-4">No kills recorded yet.</p>`;
            }
        }

        // --- GAME ACTIONS (WRITING TO FIRESTORE) ---

        async function updateFirestoreState(newState) {
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, "verbal-assassins-game-specific");
            try {
                await setDoc(gameDocRef, newState);
            } catch (error) {
                console.error("Error updating game state:", error);
                alert("Failed to update game state. Please check your connection.");
            }
        }
        
        // Shuffle the cycle
        document.getElementById('shuffle-btn').addEventListener('click', () => {
            let activePlayers = gameState.players.filter(p => p.alive);
            if (activePlayers.length < 2) {
                alert("You need at least 2 living players to shuffle.");
                return;
            }

            let shuffled = [...activePlayers].sort(() => 0.5 - Math.random());
            const words = getWordList();
            if (words.length === 0) {
                alert("Word list is not available. Cannot shuffle.");
                return;
            }
            const newPlayersState = JSON.parse(JSON.stringify(gameState.players));

            shuffled.forEach((shuffledPlayer, i) => {
                const target = shuffled[(i + 1) % shuffled.length];
                const playerInState = newPlayersState.find(p => p.name === shuffledPlayer.name);
                if (playerInState) {
                    playerInState.target = target.name;
                    playerInState.word = words[Math.floor(Math.random() * words.length)];
                }
            });
            
            const newState = { ...gameState, players: newPlayersState, gameStarted: true };
            updateFirestoreState(newState);
        });

        // Reset the game
        document.getElementById('reset-btn').addEventListener('click', () => {
            showModal(
                'Confirm Reset',
                '<p>Are you sure you want to reset the game? This will restore the original player list and clear all kills and targets.</p>',
                [
                    `<button id="cancel-btn" class="bg-slate-600 hover:bg-slate-500 font-semibold py-2 px-4 rounded-lg">Cancel</button>`,
                    `<button id="confirm-reset-btn" class="bg-rose-600 hover:bg-rose-500 font-semibold py-2 px-4 rounded-lg">Confirm Reset</button>`
                ]
            );

            document.getElementById('cancel-btn').onclick = closeModal;
            document.getElementById('confirm-reset-btn').onclick = () => {
                const newState = getInitialGameState();
                updateFirestoreState(newState);
                closeModal();
            };
        });

        // --- MODAL HANDLING ---
        
        function showModal(title, content, buttons) {
            modalContent.innerHTML = `
                <h3 class="text-xl font-bold mb-4 text-sky-300">${title}</h3>
                <div class="mb-6">${content}</div>
                <div class="flex justify-end gap-3">
                    ${buttons.join('')}
                </div>
            `;
            modalContainer.classList.remove('hidden');
        }

        function closeModal() {
            modalContainer.classList.add('hidden');
        }
        
        modalContainer.addEventListener('click', (e) => {
            if (e.target === modalContainer) {
                closeModal();
            }
        });

        // Record Kill Modal
        document.getElementById('kill-btn').addEventListener('click', () => {
            const alivePlayers = gameState.players.filter(p => p.alive && p.target);
            if (alivePlayers.length < 2) {
                alert("Not enough players with targets are alive. Try shuffling first.");
                return;
            }
            
            const options = alivePlayers.map(p => `<option value="${p.name}">${p.name} â†’ ${p.target}</option>`).join('');
            
            showModal(
                'Record a Kill',
                `<label for="killer-select" class="block mb-2 text-slate-400">Who got the kill?</label>
                 <select id="killer-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg p-2">${options}</select>`,
                [
                    `<button id="cancel-btn" class="bg-slate-600 hover:bg-slate-500 font-semibold py-2 px-4 rounded-lg">Cancel</button>`,
                    `<button id="confirm-kill-btn" class="bg-rose-600 hover:bg-rose-500 font-semibold py-2 px-4 rounded-lg">Confirm</button>`
                ]
            );

            document.getElementById('cancel-btn').onclick = closeModal;
            document.getElementById('confirm-kill-btn').onclick = () => {
                const newPlayersState = JSON.parse(JSON.stringify(gameState.players));
                const killerName = document.getElementById('killer-select').value;
                const killer = newPlayersState.find(p => p.name === killerName);
                const victim = newPlayersState.find(p => p.name === killer.target);
                
                if (!killer || !victim) {
                    alert('Error finding killer or victim. State may have changed.');
                    return;
                }

                victim.alive = false;
                killer.target = victim.target;
                killer.word = getWordList()[Math.floor(Math.random() * getWordList().length)];

                const newKillHistory = [...gameState.killHistory, {
                    killer: killer.name,
                    victim: victim.name,
                    word: killer.word,
                    timestamp: new Date().toLocaleTimeString()
                }];

                const newState = { ...gameState, players: newPlayersState, killHistory: newKillHistory };
                updateFirestoreState(newState);
                closeModal();
            };
        });
        
        // New Word Modal
        document.getElementById('word-btn').addEventListener('click', () => {
            const alivePlayers = gameState.players.filter(p => p.alive);
            const options = alivePlayers.map(p => `<option value="${p.name}">${p.name}</option>`).join('');
            
            showModal(
                'Assign New Word',
                `<label for="word-player-select" class="block mb-2 text-slate-400">Select Player:</label>
                 <select id="word-player-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg p-2">${options}</select>`,
                [
                    `<button id="cancel-btn" class="bg-slate-600 hover:bg-slate-500 font-semibold py-2 px-4 rounded-lg">Cancel</button>`,
                    `<button id="assign-word-btn" class="bg-amber-500 hover:bg-amber-400 font-semibold py-2 px-4 rounded-lg">Assign</button>`
                ]
            );

            document.getElementById('cancel-btn').onclick = closeModal;
            document.getElementById('assign-word-btn').onclick = () => {
                const newPlayersState = JSON.parse(JSON.stringify(gameState.players));
                const playerName = document.getElementById('word-player-select').value;
                const player = newPlayersState.find(p => p.name === playerName);
                player.word = getWordList()[Math.floor(Math.random() * getWordList().length)];
                
                const newState = { ...gameState, players: newPlayersState };
                updateFirestoreState(newState);
                closeModal();
            };
        });

        // --- UTILITY FUNCTIONS ---

        function getInitialGameState() {
            const playerNames = [
                'JoÃ£o', 'Cyrus', 'Ali', 'Adriani', 'Skyler', 'Andy J', 'Keiko', 'Daniel',
                'Grace', 'Alethea', 'Josie', 'Amanda', 'Doruk Ege', 'Colette', 'Srinivas', 'JJ',
                'Avery', 'Alexander', 'Sophie', 'Amy', 'Thanh', 'Jessica', 'Audrey', 'Ashvant',
                'Isaac', 'Jonathan', 'Annabel', 'Tara', 'Rio', 'Allison', 'Lucy', 'Jason',
                'Brian', 'Andy S', 'Christina', 'Amelie', 'Kevin', 'Sophia', 'Gavin', 'Lisa'
            ];
            
            return {
                players: playerNames.map(name => ({
                    name: name,
                    target: null,
                    word: null,
                    alive: true
                })),
                killHistory: [],
                gameStarted: false,
            };
        }
        
        async function loadWordList() {
            try {
                const response = await fetch('4000-most-common-english-words-csv.csv');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvContent = await response.text();
                
                const lines = csvContent.split(/\r?\n/);
                const words = [];
                
                // Use the same range as the original code: lines 501 to 3001
                for (let i = 501; i <= 3001 && i < lines.length; i++) {
                    const word = lines[i].replace(/\r/g, '').trim();
                    if (word) {
                        words.push(word);
                    }
                }
                commonWords = words;
                console.log(`Successfully loaded ${commonWords.length} words from CSV.`);
            } catch (error) {
                console.warn('Could not load CSV file. Using fallback word list.', error);
                // Fallback to a hardcoded list if the CSV is not found
                commonWords = [
                    'doctor', 'wall', 'patient', 'worker', 'news', 'test', 'movie', 'certain',
                    'north', 'love', 'personal', 'open', 'support', 'simply', 'third',
                    'technology', 'catch', 'step', 'baby', 'computer', 'type', 'attention',
                    'draw', 'film', 'republican', 'tree', 'source', 'red', 'nearly',
                    'organization', 'choose', 'cause', 'hair', 'century', 'evidence', 'window',
                    'difficult', 'listen', 'soon', 'culture', 'billion', 'chance', 'brother',
                    'energy', 'period', 'course', 'summer', 'realize', 'hundred', 'available',
                    'plant', 'likely', 'opportunity', 'term', 'chair', 'protect', 'parent',
                    'interview', 'yesterday', 'sell', 'fire', 'particularly', 'forget', 'cold'
                ];
            }
        }

        function getWordList() {
            return commonWords;
        }

        // --- START THE APP ---
        main();

    </script>
</body>
</html>
