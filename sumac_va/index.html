<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verbal Assassins Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            background: #1a1a1a;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        h1 {
            text-align: center;
            font-size: 3em;
            margin-bottom: 40px;
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 40px rgba(255, 107, 107, 0.3);
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        button:before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        button:hover:before {
            width: 300px;
            height: 300px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: #333;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .section {
            background: #262626;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .section h2 {
            font-size: 1.8em;
            margin-bottom: 20px;
            color: #4ecdc4;
        }
        
        .player-list {
            display: grid;
            gap: 15px;
        }
        
        .player-card {
            background: #333;
            border-radius: 10px;
            padding: 15px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            align-items: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .player-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(78, 205, 196, 0.1);
        }
        
        .player-card.eliminated {
            opacity: 0.5;
            background: #2a2a2a;
        }
        
        .player-name {
            font-weight: bold;
            color: #ff6b6b;
        }
        
        .target {
            color: #4ecdc4;
        }
        
        .word {
            font-family: monospace;
            background: #444;
            padding: 5px 10px;
            border-radius: 5px;
            text-align: center;
        }
        
        .kill-entry {
            padding: 10px;
            background: #2a2a2a;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: #262626;
            padding: 30px;
            border-radius: 15px;
            max-width: 400px;
            width: 90%;
            animation: modalPop 0.3s ease;
        }
        
        @keyframes modalPop {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .modal h3 {
            margin-bottom: 20px;
            color: #4ecdc4;
        }
        
        select {
            width: 100%;
            padding: 10px;
            margin-bottom: 20px;
            background: #333;
            border: 1px solid #444;
            color: #e0e0e0;
            border-radius: 5px;
            font-size: 16px;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: #333;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .stat-label {
            color: #888;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Verbal Assassins</h1>
        
        <div class="controls">
            <button class="btn-primary" onclick="initializePlayers()">Initialize Players</button>
            <button class="btn-success" onclick="shuffleCycle()">üîÄ Shuffle Cycle</button>
            <button class="btn-danger" onclick="showKillModal()">üíÄ Record Kill</button>
            <button class="btn-warning" onclick="showWordModal()">üé≤ New Word</button>
            <button class="btn-primary" onclick="showUndoModal()">‚Ü©Ô∏è Undo Kill</button>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="players-alive">0</div>
                <div class="stat-label">Players Alive</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="players-dead">0</div>
                <div class="stat-label">Eliminated</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="total-kills">0</div>
                <div class="stat-label">Total Kills</div>
            </div>
        </div>
        
        <div class="grid">
            <div class="section">
                <h2>Active Players</h2>
                <div id="player-list" class="player-list"></div>
            </div>
            
            <div class="section">
                <h2>Kill History</h2>
                <div id="kill-history"></div>
            </div>
        </div>
    </div>
    
    <!-- Kill Modal -->
    <div id="kill-modal" class="modal">
        <div class="modal-content">
            <h3>Record Kill</h3>
            <label>Who got the kill?</label>
            <select id="killer-select"></select>
            <div class="modal-buttons">
                <button class="btn-danger" onclick="confirmKill()">Confirm Kill</button>
                <button onclick="closeModal('kill-modal')">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Word Modal -->
    <div id="word-modal" class="modal">
        <div class="modal-content">
            <h3>Assign New Word</h3>
            <label>Select player:</label>
            <select id="word-player-select"></select>
            <div class="modal-buttons">
                <button class="btn-warning" onclick="assignNewWord()">Assign Word</button>
                <button onclick="closeModal('word-modal')">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Undo Modal -->
    <div id="undo-modal" class="modal">
        <div class="modal-content">
            <h3>Undo Kill</h3>
            <label>Select kill to undo:</label>
            <select id="undo-select" size="10" style="height: 200px;"></select>
            <div class="modal-buttons">
                <button class="btn-primary" onclick="confirmUndo()">Undo Selected</button>
                <button onclick="closeModal('undo-modal')">Cancel</button>
            </div>
        </div>
    </div>
    
    <script>
        // game state - all in memory as requested
        let players = [];
        let killHistory = [];
        let gameStates = []; // store all game states for undo functionality
        let commonWords = [];
        
        // initialize with 40 players
        async function initializePlayers() {
            // create array of player names
            const playerNames = [
                'Jo√£o', 'Cyrus', 'Ali', 'Adriani', 'Skyler', 'Andy J', 'Keiko', 'Daniel',
                'Grace', 'Alethea', 'Josie', 'Amanda', 'Doruk Ege', 'Colette', 'Srinivas', 'JJ',
                'Avery', 'Alexander', 'Sophie', 'Amy', 'Thanh', 'Jessica', 'Audrey', 'Ashvant',
                'Isaac', 'Jonathan', 'Annabel', 'Tara', 'Rio', 'Allison', 'Lucy', 'Jason',
                'Brian', 'Andy S', 'Christina', 'Amelie', 'Kevin', 'Sophia', 'Gavin', 'Lisa'
            ];
            players = playerNames; // start with string array
            
            // load word list (from the CSV if available)
            await loadWordList();
            shuffleCycle();
        }
        
        // load word list from CSV file
        async function loadWordList() {
            try {
                // fetch the csv from same directory as the html file
                const response = await fetch('4000-most-common-english-words-csv.csv');
                const csvContent = await response.text();
                
                // parse csv - it has one column with header
                const lines = csvContent.split(/\r?\n/); // handle both unix and windows line endings
                commonWords = [];
                
                // skip header, get words from line 501 to 3001 (index 500-3000)
                for (let i = 501; i <= 3001 && i < lines.length; i++) {
                    // remove any whitespace and carriage returns
                    const word = lines[i].replace(/\r/g, '').trim();
                    if (word && word.length > 0) {
                        commonWords.push(word);
                    }
                }
                
                console.log(`Loaded ${commonWords.length} words from CSV`);
                console.log('Sample words:', commonWords.slice(0, 5)); // show first 5 words for debugging
                
            } catch (error) {
                // fallback to hardcoded list if csv not available
                console.log('CSV not found or error parsing, using fallback word list:', error);
                // these are actual words from around the 500-3000 range in common word lists
                commonWords = [
                    'doctor', 'wall', 'patient', 'worker', 'news', 'test', 'movie', 'certain',
                    'north', 'love', 'personal', 'open', 'support', 'simply', 'third',
                    'technology', 'catch', 'step', 'baby', 'computer', 'type', 'attention',
                    'draw', 'film', 'republican', 'tree', 'source', 'red', 'nearly',
                    'organization', 'choose', 'cause', 'hair', 'century', 'evidence', 'window',
                    'difficult', 'listen', 'soon', 'culture', 'billion', 'chance', 'brother',
                    'energy', 'period', 'course', 'summer', 'realize', 'hundred', 'available',
                    'plant', 'likely', 'opportunity', 'term', 'chair', 'protect', 'parent',
                    'interview', 'yesterday', 'sell', 'fire', 'particularly', 'forget', 'cold',
                    'represent', 'focus', 'foreign', 'throughout', 'upon', 'agency', 'push',
                    'nature', 'recently', 'store', 'reduce', 'sound', 'note', 'fine',
                    'near', 'movement', 'page', 'enter', 'share', 'common', 'poor',
                    'natural', 'race', 'concern', 'series', 'significant', 'similar', 'language',
                    'usually', 'response', 'dead', 'rise', 'animal', 'factor', 'decade',
                    'shoot', 'east', 'save', 'seven', 'artist', 'scene', 'stock', 'career'
                ];
            }
        }
        
        function getRandomWord() {
            // mimics python random.randrange(1000, 4000) 
            // which means words from index 1000-3999 in the original csv
            // but we're only loading words 500-3000 (the range the user wants)
            if (commonWords.length === 0) {
                console.error('No words loaded!');
                return 'ERROR'; // visible error to help debug
            }
            return commonWords[Math.floor(Math.random() * commonWords.length)];
        }
        
        function shuffleCycle() {
            if (players.length === 0) {
                alert('Initialize players first!');
                return;
            }
            
            // get player names (handle both initial string array and object array)
            const playerNames = players.map(p => typeof p === 'string' ? p : p.name);
            
            // create game state
            const availableTargets = [...Array(playerNames.length).keys()];
            const assignments = new Array(playerNames.length);
            
            // create a cycle like in the python code
            let current = 0;
            availableTargets.splice(0, 1); // remove first player from targets
            
            while (availableTargets.length > 0) {
                const targetIndex = Math.floor(Math.random() * availableTargets.length);
                const target = availableTargets[targetIndex];
                assignments[current] = target;
                availableTargets.splice(targetIndex, 1);
                current = target;
            }
            assignments[current] = 0; // complete the cycle
            
            // create player objects
            players = playerNames.map((name, i) => ({
                name: name,
                target: playerNames[assignments[i]], // use the name from playerNames array
                targetIndex: assignments[i],
                word: getRandomWord(),
                alive: true
            }));
            
            killHistory = [];
            updateDisplay();
        }
        
        function showKillModal() {
            const select = document.getElementById('killer-select');
            select.innerHTML = '';
            
            // only show alive players who have targets
            const alivePlayers = players.filter(p => p.alive);
            alivePlayers.forEach(player => {
                const option = document.createElement('option');
                option.value = player.name;
                option.textContent = `${player.name} ‚Üí ${player.target}`;
                select.appendChild(option);
            });
            
            document.getElementById('kill-modal').style.display = 'flex';
        }
        
        function confirmKill() {
            const killerName = document.getElementById('killer-select').value;
            const killer = players.find(p => p.name === killerName);
            
            if (!killer) return;
            
            // save current state before making changes
            gameStates.push({
                players: JSON.parse(JSON.stringify(players)),
                killHistory: JSON.parse(JSON.stringify(killHistory))
            });
            
            // find the victim
            const victim = players.find(p => p.name === killer.target);
            
            // record the kill
            killHistory.push({
                killer: killer.name,
                victim: victim.name,
                word: killer.word,
                timestamp: new Date().toLocaleTimeString()
            });
            
            // killer inherits victim's target  
            killer.target = victim.target; // this should already be a string
            killer.targetIndex = victim.targetIndex;
            killer.word = getRandomWord(); // new word for killer
            
            // mark victim as dead
            victim.alive = false;
            
            closeModal('kill-modal');
            updateDisplay();
        }
        
        function showWordModal() {
            const select = document.getElementById('word-player-select');
            select.innerHTML = '';
            
            const alivePlayers = players.filter(p => p.alive);
            alivePlayers.forEach(player => {
                const option = document.createElement('option');
                option.value = player.name;
                option.textContent = player.name;
                select.appendChild(option);
            });
            
            document.getElementById('word-modal').style.display = 'flex';
        }
        
        function assignNewWord() {
            const playerName = document.getElementById('word-player-select').value;
            const player = players.find(p => p.name === playerName);
            
            if (player) {
                player.word = getRandomWord();
                closeModal('word-modal');
                updateDisplay();
            }
        }
        
        function showUndoModal() {
            if (gameStates.length === 0) {
                alert('No kills to undo!');
                return;
            }
            
            const select = document.getElementById('undo-select');
            select.innerHTML = '';
            
            // show the initial state
            const initialOption = document.createElement('option');
            initialOption.value = '0';
            initialOption.textContent = 'Initial State (No Kills)';
            select.appendChild(initialOption);
            
            // show all kill states
            killHistory.forEach((kill, index) => {
                const option = document.createElement('option');
                option.value = index + 1;
                option.textContent = `After Kill ${index + 1}: ${kill.killer} ‚Üí ${kill.victim} (${kill.timestamp})`;
                select.appendChild(option);
            });
            
            // select the most recent state by default
            select.value = killHistory.length;
            
            document.getElementById('undo-modal').style.display = 'flex';
        }
        
        function confirmUndo() {
            const select = document.getElementById('undo-select');
            const stateIndex = parseInt(select.value);
            
            if (stateIndex === 0) {
                // restore to initial state (before any kills)
                if (gameStates.length > 0) {
                    const initialState = gameStates[0];
                    players = JSON.parse(JSON.stringify(initialState.players));
                    // reset everyone to alive since this is before any kills
                    players.forEach(p => p.alive = true);
                    killHistory = [];
                    gameStates = [];
                }
            } else {
                // restore to state after specific kill
                const targetState = gameStates[stateIndex - 1];
                players = JSON.parse(JSON.stringify(targetState.players));
                killHistory = JSON.parse(JSON.stringify(targetState.killHistory));
                // keep only the game states up to this point
                gameStates = gameStates.slice(0, stateIndex);
                
                // apply all kills up to this point
                for (let i = 0; i < stateIndex; i++) {
                    const kill = killHistory[i];
                    const killer = players.find(p => p.name === kill.killer);
                    const victim = players.find(p => p.name === kill.victim);
                    
                    if (killer && victim) {
                        killer.target = victim.target;
                        killer.targetIndex = victim.targetIndex;
                        victim.alive = false;
                    }
                }
            }
            
            closeModal('undo-modal');
            updateDisplay();
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }
        
        function updateDisplay() {
            // update stats
            const alivePlayers = players.filter(p => p.alive);
            document.getElementById('players-alive').textContent = alivePlayers.length;
            document.getElementById('players-dead').textContent = players.length - alivePlayers.length;
            document.getElementById('total-kills').textContent = killHistory.length;
            
            // update player list
            const playerList = document.getElementById('player-list');
            playerList.innerHTML = '';
            
            players.forEach(player => {
                if (!player.alive) return;
                
                const card = document.createElement('div');
                card.className = 'player-card';
                card.innerHTML = `
                    <div class="player-name">${player.name}</div>
                    <div>Target: <span class="target">${player.target}</span></div>
                    <div class="word">${player.word}</div>
                `;
                playerList.appendChild(card);
            });
            
            // update kill history
            const historyDiv = document.getElementById('kill-history');
            historyDiv.innerHTML = '';
            
            // show most recent kills first
            killHistory.slice().reverse().forEach((kill, index) => {
                const entry = document.createElement('div');
                entry.className = 'kill-entry';
                entry.innerHTML = `
                    <div>
                        <strong>${kill.killer}</strong> eliminated <strong>${kill.victim}</strong>
                        <br><small>Word: ${kill.word} ‚Ä¢ ${kill.timestamp}</small>
                    </div>
                `;
                historyDiv.appendChild(entry);
            });
        }
        
        // initialize on load
        window.onload = async function() {
            await initializePlayers();
        };    </script>
</body>
</html>
