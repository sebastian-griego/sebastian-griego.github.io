<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verbal Assassins - Multiplayer</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for better aesthetics in dark mode */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b;
        }
        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
        /* Simple animation for elements fading in */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-200 antialiased">

    <div id="app" class="container mx-auto p-4 md:p-8 max-w-7xl">

        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-extrabold bg-gradient-to-r from-rose-400 via-fuchsia-500 to-indigo-500 bg-clip-text text-transparent pb-2">
                Verbal Assassins
            </h1>
            <p class="text-slate-400">A real-time multiplayer assassination game for our group.</p>
            
            <!-- Bracket Selector -->
            <div class="mt-6 mb-4">
                <div class="inline-flex rounded-lg bg-slate-800 p-1">
                    <button id="main-bracket-btn" class="px-6 py-2 rounded-md font-semibold transition-all duration-200 bg-indigo-600 text-white">
                        🏆 Main Bracket
                    </button>
                    <button id="losers-bracket-btn" class="px-6 py-2 rounded-md font-semibold transition-all duration-200 text-slate-400 hover:text-white">
                        💀 Losers Bracket
                    </button>
                </div>
            </div>
            
            <div id="bracket-indicator" class="text-lg font-bold mb-2">
                <span class="text-indigo-400">Currently viewing: Main Bracket</span>
            </div>
            
            <div id="user-info" class="mt-4 text-xs text-slate-500 bg-slate-800 rounded-md p-2 inline-block">
                Connecting...
            </div>
        </header>

        <!-- Loading State -->
        <div id="loading" class="text-center py-10">
            <p class="text-lg text-slate-400">Loading Game State...</p>
        </div>

        <!-- Game Content (hidden until loaded) -->
        <main id="game-content" class="hidden">
            <!-- Controls -->
            <div id="controls" class="flex flex-wrap justify-center gap-3 mb-8 fade-in">
                <button id="shuffle-btn" class="bg-green-600 hover:bg-green-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">🔀 Shuffle Cycle</button>
                <button id="set-target-btn" class="bg-sky-600 hover:bg-sky-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">🎯 Set Target</button>
                <button id="kill-btn" class="bg-rose-600 hover:bg-rose-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">💀 Record Kill</button>
                <button id="undo-kill-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">↩️ Undo Kill</button>
                <button id="word-btn" class="bg-amber-500 hover:bg-amber-400 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">🎲 New Word</button>
                <button id="backup-btn" class="bg-purple-600 hover:bg-purple-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">💾 Save Backup</button>
                <button id="restore-btn" class="bg-teal-600 hover:bg-teal-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">📂 Restore Backup</button>
                <button id="reset-btn" class="bg-slate-600 hover:bg-slate-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">🔄 Reset Game</button>
            </div>
            
            <!-- Stats -->
            <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-8 fade-in">
                <div class="bg-slate-800 p-4 rounded-xl text-center shadow-lg"><div id="players-alive" class="text-3xl font-bold text-green-400">0</div><div class="text-slate-400">Players Alive</div></div>
                <div class="bg-slate-800 p-4 rounded-xl text-center shadow-lg"><div id="players-dead" class="text-3xl font-bold text-rose-400">0</div><div class="text-slate-400">Eliminated</div></div>
                <div class="bg-slate-800 p-4 rounded-xl text-center shadow-lg"><div id="total-kills" class="text-3xl font-bold text-sky-400">0</div><div class="text-slate-400">Total Kills</div></div>
            </div>

            <!-- Last save info -->
            <div id="last-save-info" class="text-center mb-4 text-sm text-slate-500"></div>

            <!-- Main Grid -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Players Section -->
                <div class="lg:col-span-2 bg-slate-800 p-6 rounded-xl shadow-lg fade-in">
                    <h2 class="text-2xl font-bold mb-4 text-sky-400">Player Roster</h2>
                    <div id="player-list" class="space-y-3"></div>
                </div>
                <!-- Kill History Section -->
                <div class="bg-slate-800 p-6 rounded-xl shadow-lg fade-in">
                    <h2 class="text-2xl font-bold mb-4 text-rose-400">Kill History</h2>
                    <div id="kill-history" class="space-y-3 max-h-[60vh] overflow-y-auto pr-2"></div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modals -->
    <div id="modal-container" class="fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center p-4 hidden">
        <div id="modal-content" class="bg-slate-800 rounded-xl shadow-2xl p-6 w-full max-w-md fade-in">
            <!-- Modal content will be injected here -->
        </div>
    </div>
    
    <!-- Firebase SDKs -->
    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, getDoc, updateDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL VARIABLES & CONFIG ---
        const appId = 'default-verbal-assassins';
        let currentBracket = 'main'; // track which bracket we're viewing

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCKPxc3X1-_6qBgEKiyVkoAivGsyShZnMk",
            authDomain: "sumacva-8fbcf.firebaseapp.com",
            projectId: "sumacva-8fbcf",
            storageBucket: "sumacva-8fbcf.firebasestorage.app",
            messagingSenderId: "437614442481",
            appId: "1:437614442481:web:f090082af7324702083650"
        };

        let app, db, auth;
        let userId = null;
        let gameUnsubscribe = null;
        let gameState = {};
        let commonWords = [];

        const loadingEl = document.getElementById('loading');
        const gameContentEl = document.getElementById('game-content');
        const userInfoEl = document.getElementById('user-info');
        const modalContainer = document.getElementById('modal-container');
        const modalContent = document.getElementById('modal-content');
        const lastSaveInfo = document.getElementById('last-save-info');
        const bracketIndicator = document.getElementById('bracket-indicator');

        // bracket switching
        const mainBracketBtn = document.getElementById('main-bracket-btn');
        const losersBracketBtn = document.getElementById('losers-bracket-btn');

        // --- BRACKET SWITCHING ---
        
        mainBracketBtn.addEventListener('click', () => {
            if (currentBracket !== 'main') {
                currentBracket = 'main';
                updateBracketUI();
                if (userId) connectToGame();
            }
        });

        losersBracketBtn.addEventListener('click', () => {
            if (currentBracket !== 'losers') {
                currentBracket = 'losers';
                updateBracketUI();
                if (userId) connectToGame();
            }
        });

        function updateBracketUI() {
            // update button styles
            if (currentBracket === 'main') {
                mainBracketBtn.className = "px-6 py-2 rounded-md font-semibold transition-all duration-200 bg-indigo-600 text-white";
                losersBracketBtn.className = "px-6 py-2 rounded-md font-semibold transition-all duration-200 text-slate-400 hover:text-white";
                bracketIndicator.innerHTML = '<span class="text-indigo-400">Currently viewing: Main Bracket</span>';
            } else {
                mainBracketBtn.className = "px-6 py-2 rounded-md font-semibold transition-all duration-200 text-slate-400 hover:text-white";
                losersBracketBtn.className = "px-6 py-2 rounded-md font-semibold transition-all duration-200 bg-rose-600 text-white";
                bracketIndicator.innerHTML = '<span class="text-rose-400">Currently viewing: Losers Bracket</span>';
            }
        }

        // --- INITIALIZATION ---

        async function main() {
            await loadWordList(); 

            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        userInfoEl.innerHTML = `Your User ID: <span class="font-mono text-sky-400">${userId}</span>`;
                        connectToGame();
                    } else {
                        userId = null;
                        userInfoEl.textContent = "Not signed in.";
                        if (gameUnsubscribe) gameUnsubscribe();
                    }
                });

                await signInAnonymously(auth);
            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                loadingEl.innerHTML = `<p class="text-lg text-red-400">Error: Could not connect to the game service.</p><p class="text-sm text-slate-500">${error.message}</p>`;
            }
        }
        
        // --- FIRESTORE REAL-TIME CONNECTION ---

        async function connectToGame() {
            // unsubscribe from previous game if switching brackets
            if (gameUnsubscribe) {
                gameUnsubscribe();
                gameUnsubscribe = null;
            }

            // use different document IDs for main and losers brackets
            const gameDocId = currentBracket === 'main' 
                ? "verbal-assassins-game-specific" 
                : "verbal-assassins-losers-bracket";
            
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, gameDocId);

            try {
                // first, check if document exists to avoid accidental resets
                const docSnap = await getDoc(gameDocRef);
                
                if (!docSnap.exists()) {
                    // instead of auto-creating, ask the user
                    const bracketName = currentBracket === 'main' ? 'Main Bracket' : 'Losers Bracket';
                    loadingEl.innerHTML = `
                        <p class="text-lg text-amber-400 mb-4">No ${bracketName} game found!</p>
                        <p class="text-slate-400 mb-4">Would you like to start a new ${bracketName} game?</p>
                        <button id="create-new-game" class="bg-green-600 hover:bg-green-500 text-white font-semibold py-2 px-5 rounded-lg">Create New ${bracketName} Game</button>
                    `;
                    
                    document.getElementById('create-new-game').addEventListener('click', async () => {
                        const initialState = getInitialGameState();
                        await setDoc(gameDocRef, initialState);
                        location.reload(); // reload to connect properly
                    });
                    return;
                }

                // now set up real-time listener
                gameUnsubscribe = onSnapshot(gameDocRef, (docSnap) => {
                    loadingEl.classList.add('hidden');
                    gameContentEl.classList.remove('hidden');

                    if (docSnap.exists()) {
                        gameState = docSnap.data();
                        updateDisplay();
                        
                        // show last update time if available
                        if (gameState.lastUpdated?.toDate) {
                            const date = gameState.lastUpdated.toDate();
                            lastSaveInfo.textContent = `Last update: ${date.toLocaleString()}`;
                        }
                    }
                }, (error) => {
                    console.error("Error listening to game state:", error);
                    loadingEl.innerHTML = `<p class="text-red-400">Error: Lost connection to the game.</p><p class="text-sm text-slate-500">${error.message}</p>`;
                });

            } catch (error) {
                console.error("Error connecting to game:", error);
                loadingEl.innerHTML = `<p class="text-red-400">Error: Could not connect to game.</p><p class="text-sm text-slate-500">${error.message}</p>`;
            }
        }

        // --- UI UPDATE FUNCTION ---

        function updateDisplay() {
            if (!gameState) return;

            const alivePlayers = gameState.players ? gameState.players.filter(p => p.alive) : [];
            document.getElementById('players-alive').textContent = alivePlayers.length;
            document.getElementById('players-dead').textContent = (gameState.players?.length || 0) - alivePlayers.length;
            document.getElementById('total-kills').textContent = gameState.killHistory?.length || 0;

            const playerList = document.getElementById('player-list');
            playerList.innerHTML = '';
            if (gameState.players && gameState.players.length > 0) {
                const sortedPlayers = [...gameState.players].sort((a, b) => {
                    if (a.alive && !b.alive) return -1;
                    if (!a.alive && b.alive) return 1;
                    return a.name.localeCompare(b.name);
                });

                sortedPlayers.forEach(player => {
                    const playerCard = document.createElement('div');
                    playerCard.className = `p-4 rounded-lg grid grid-cols-1 md:grid-cols-3 gap-4 items-center transition-all duration-300 ${player.alive ? 'bg-slate-700' : 'bg-slate-800/50 opacity-50'}`;
                    
                    const targetInfo = player.target || 'N/A';
                    const wordInfo = player.word || 'N/A';

                    playerCard.innerHTML = `
                        <div class="font-bold text-lg ${player.alive ? 'text-white' : 'text-slate-500 line-through'}">${player.name}</div>
                        <div class="text-slate-400">Target: <span class="font-semibold text-rose-400">${targetInfo}</span></div>
                        <div class="text-slate-400">Word: <span class="font-mono bg-slate-600 px-2 py-1 rounded text-amber-300">${wordInfo}</span></div>
                    `;
                    playerList.appendChild(playerCard);
                });
            } else {
                playerList.innerHTML = `<p class="text-slate-500 text-center py-4">Game not initialized. Click Reset Game.</p>`;
            }

            const killHistoryEl = document.getElementById('kill-history');
            killHistoryEl.innerHTML = '';
            if (gameState.killHistory && gameState.killHistory.length > 0) {
                [...gameState.killHistory].reverse().forEach(kill => {
                    const killEntry = document.createElement('div');
                    killEntry.className = 'bg-slate-700/50 p-3 rounded-lg';
                    killEntry.innerHTML = `
                        <div>
                            <span class="font-bold text-rose-400">${kill.killer}</span> eliminated <span class="font-bold text-slate-400">${kill.victim}</span>
                        </div>
                        <div class="text-xs text-slate-500 mt-1">Word: <span class="font-mono">${kill.word}</span> at ${kill.timestamp}</div>
                    `;
                    killHistoryEl.appendChild(killEntry);
                });
            } else {
                killHistoryEl.innerHTML = `<p class="text-slate-500 text-center py-4">No kills recorded yet.</p>`;
            }
        }

        // --- GAME ACTIONS (WRITING TO FIRESTORE) ---

        async function updateFirestoreState(newState) {
            const gameDocId = currentBracket === 'main' 
                ? "verbal-assassins-game-specific" 
                : "verbal-assassins-losers-bracket";
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, gameDocId);
            
            try {
                // add timestamp to track when changes happen
                newState.lastUpdated = serverTimestamp();
                newState.lastUpdatedBy = userId;
                
                await setDoc(gameDocRef, newState);
            } catch (error) {
                console.error("Error updating game state:", error);
                alert("Failed to update game state. Please check your connection.");
            }
        }

        // backup functionality - now includes bracket info
        async function saveBackup() {
            const backupData = {
                ...gameState,
                backupDate: new Date().toISOString(),
                backupBy: userId,
                bracket: currentBracket // remember which bracket this backup is from
            };
            
            // store in browser's local storage with timestamp and bracket
            const backupKey = `verbal-assassins-backup-${currentBracket}-${new Date().getTime()}`;
            localStorage.setItem(backupKey, JSON.stringify(backupData));
            
            // also store reference to latest backup for this bracket
            localStorage.setItem(`verbal-assassins-latest-backup-${currentBracket}`, backupKey);
            
            // keep only last 5 backups per bracket to save space
            const allKeys = Object.keys(localStorage).filter(k => k.startsWith(`verbal-assassins-backup-${currentBracket}-`));
            if (allKeys.length > 5) {
                allKeys.sort();
                const toRemove = allKeys.slice(0, allKeys.length - 5);
                toRemove.forEach(key => localStorage.removeItem(key));
            }
            
            const bracketName = currentBracket === 'main' ? 'Main Bracket' : 'Losers Bracket';
            alert(`${bracketName} backup saved! (${new Date().toLocaleTimeString()})`);
        }

        async function showRestoreOptions() {
            const allBackups = Object.keys(localStorage)
                .filter(k => k.startsWith(`verbal-assassins-backup-${currentBracket}-`))
                .sort()
                .reverse();
            
            if (allBackups.length === 0) {
                const bracketName = currentBracket === 'main' ? 'Main Bracket' : 'Losers Bracket';
                alert(`No backups found for ${bracketName} in your browser.`);
                return;
            }
            
            const options = allBackups.map(key => {
                const backup = JSON.parse(localStorage.getItem(key));
                const date = new Date(backup.backupDate);
                const aliveCount = backup.players?.filter(p => p.alive).length || 0;
                const killCount = backup.killHistory?.length || 0;
                return `<option value="${key}">${date.toLocaleString()} - ${aliveCount} alive, ${killCount} kills</option>`;
            }).join('');
            
            const bracketName = currentBracket === 'main' ? 'Main Bracket' : 'Losers Bracket';
            showModal(
                `Restore ${bracketName} from Backup`,
                `<label for="backup-select" class="block mb-2 text-slate-400">Select a backup to restore:</label>
                 <select id="backup-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg p-2 mb-4">${options}</select>
                 <p class="text-amber-400 text-sm">⚠️ This will overwrite the current ${bracketName} game state!</p>`,
                [
                    `<button id="cancel-btn" class="bg-slate-600 hover:bg-slate-500 font-semibold py-2 px-4 rounded-lg">Cancel</button>`,
                    `<button id="confirm-restore-btn" class="bg-teal-600 hover:bg-teal-500 font-semibold py-2 px-4 rounded-lg">Restore</button>`
                ]
            );

            document.getElementById('cancel-btn').onclick = closeModal;
            document.getElementById('confirm-restore-btn').onclick = async () => {
                const selectedKey = document.getElementById('backup-select').value;
                const backupData = JSON.parse(localStorage.getItem(selectedKey));
                
                // remove backup metadata before restoring
                delete backupData.backupDate;
                delete backupData.backupBy;
                delete backupData.bracket;
                
                await updateFirestoreState(backupData);
                closeModal();
                alert("Game restored from backup!");
            };
        }

        // add event listeners for new buttons
        document.getElementById('backup-btn').addEventListener('click', saveBackup);
        document.getElementById('restore-btn').addEventListener('click', showRestoreOptions);
        
        document.getElementById('shuffle-btn').addEventListener('click', () => {
            let activePlayers = gameState.players.filter(p => p.alive);
            if (activePlayers.length < 2) {
                alert("You need at least 2 living players to shuffle.");
                return;
            }

            let shuffled = [...activePlayers].sort(() => 0.5 - Math.random());
            const words = getWordList();
            if (words.length === 0) {
                alert("Word list is not available. Cannot shuffle.");
                return;
            }
            const newPlayersState = JSON.parse(JSON.stringify(gameState.players));

            shuffled.forEach((shuffledPlayer, i) => {
                const target = shuffled[(i + 1) % shuffled.length];
                const playerInState = newPlayersState.find(p => p.name === shuffledPlayer.name);
                if (playerInState) {
                    playerInState.target = target.name;
                    playerInState.word = words[Math.floor(Math.random() * words.length)];
                }
            });
            
            const newState = { ...gameState, players: newPlayersState, gameStarted: true };
            updateFirestoreState(newState);
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            const bracketName = currentBracket === 'main' ? 'Main Bracket' : 'Losers Bracket';
            showModal(
                `Confirm Reset ${bracketName}`,
                `<p>Are you sure you want to reset the ${bracketName} game? This will restore the original player list and clear all kills and targets.</p><p class="text-amber-400 text-sm mt-2">💡 Tip: Save a backup first!</p>`,
                [
                    `<button id="cancel-btn" class="bg-slate-600 hover:bg-slate-500 font-semibold py-2 px-4 rounded-lg">Cancel</button>`,
                    `<button id="confirm-reset-btn" class="bg-rose-600 hover:bg-rose-500 font-semibold py-2 px-4 rounded-lg">Confirm Reset</button>`
                ]
            );

            document.getElementById('cancel-btn').onclick = closeModal;
            document.getElementById('confirm-reset-btn').onclick = () => {
                const newState = getInitialGameState();
                updateFirestoreState(newState);
                closeModal();
            };
        });

        // --- MODAL HANDLING ---
        
        function showModal(title, content, buttons) {
            modalContent.innerHTML = `
                <h3 class="text-xl font-bold mb-4 text-sky-300">${title}</h3>
                <div class="mb-6">${content}</div>
                <div class="flex justify-end gap-3">
                    ${buttons.join('')}
                </div>
            `;
            modalContainer.classList.remove('hidden');
        }

        function closeModal() {
            modalContainer.classList.add('hidden');
        }
        
        modalContainer.addEventListener('click', (e) => {
            if (e.target === modalContainer) {
                closeModal();
            }
        });

        document.getElementById('kill-btn').addEventListener('click', () => {
            const alivePlayers = gameState.players.filter(p => p.alive && p.target);
            if (alivePlayers.length < 2) {
                alert("Not enough players with targets are alive. Try shuffling first.");
                return;
            }
            
            const options = alivePlayers.map(p => `<option value="${p.name}">${p.name} → ${p.target}</option>`).join('');
            
            showModal(
                'Record a Kill',
                `<label for="killer-select" class="block mb-2 text-slate-400">Who got the kill?</label>
                 <select id="killer-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg p-2">${options}</select>`,
                [
                    `<button id="cancel-btn" class="bg-slate-600 hover:bg-slate-500 font-semibold py-2 px-4 rounded-lg">Cancel</button>`,
                    `<button id="confirm-kill-btn" class="bg-rose-600 hover:bg-rose-500 font-semibold py-2 px-4 rounded-lg">Confirm</button>`
                ]
            );

            document.getElementById('cancel-btn').onclick = closeModal;
            document.getElementById('confirm-kill-btn').onclick = () => {
                const newPlayersState = JSON.parse(JSON.stringify(gameState.players));
                const killerName = document.getElementById('killer-select').value;
                const killer = newPlayersState.find(p => p.name === killerName);
                const victim = newPlayersState.find(p => p.name === killer.target);
                
                if (!killer || !victim) {
                    alert('Error finding killer or victim. State may have changed.');
                    return;
                }

                // Store the killer's state BEFORE the kill for undo purposes
                const originalKillerTarget = killer.target;
                const originalKillerWord = killer.word;

                // Apply the kill
                victim.alive = false;
                killer.target = victim.target;
                killer.word = getWordList()[Math.floor(Math.random() * getWordList().length)];

                // Add the kill to history, now with the original state saved
                const newKillHistory = [...(gameState.killHistory || []), {
                    killer: killer.name,
                    victim: victim.name,
                    word: killer.word, // The new word for the killer
                    timestamp: new Date().toLocaleTimeString(),
                    originalKillerTarget: originalKillerTarget,
                    originalKillerWord: originalKillerWord
                }];

                const newState = { ...gameState, players: newPlayersState, killHistory: newKillHistory };
                updateFirestoreState(newState);
                closeModal();
            };
        });
        
        document.getElementById('word-btn').addEventListener('click', () => {
            const alivePlayers = gameState.players.filter(p => p.alive);
            const options = alivePlayers.map(p => `<option value="${p.name}">${p.name}</option>`).join('');
            
            showModal(
                'Assign New Word',
                `<label for="word-player-select" class="block mb-2 text-slate-400">Select Player:</label>
                 <select id="word-player-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg p-2">${options}</select>`,
                [
                    `<button id="cancel-btn" class="bg-slate-600 hover:bg-slate-500 font-semibold py-2 px-4 rounded-lg">Cancel</button>`,
                    `<button id="assign-word-btn" class="bg-amber-500 hover:bg-amber-400 font-semibold py-2 px-4 rounded-lg">Assign</button>`
                ]
            );

            document.getElementById('cancel-btn').onclick = closeModal;
            document.getElementById('assign-word-btn').onclick = () => {
                const newPlayersState = JSON.parse(JSON.stringify(gameState.players));
                const playerName = document.getElementById('word-player-select').value;
                const player = newPlayersState.find(p => p.name === playerName);
                player.word = getWordList()[Math.floor(Math.random() * getWordList().length)];
                
                const newState = { ...gameState, players: newPlayersState };
                updateFirestoreState(newState);
                closeModal();
            };
        });

        document.getElementById('undo-kill-btn').addEventListener('click', () => {
            if (!gameState.killHistory || gameState.killHistory.length === 0) {
                alert("There are no kills to undo.");
                return;
            }
            
            const options = gameState.killHistory.map((kill, index) => 
                `<option value="${index}">${kill.killer} → ${kill.victim} (${kill.timestamp})</option>`
            ).join('');

            showModal(
                'Undo a Kill',
                `<label for="undo-select" class="block mb-2 text-slate-400">Select kill to remove:</label>
                 <select id="undo-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg p-2">${options}</select>`,
                [
                    `<button id="cancel-btn" class="bg-slate-600 hover:bg-slate-500 font-semibold py-2 px-4 rounded-lg">Cancel</button>`,
                    `<button id="confirm-undo-btn" class="bg-indigo-600 hover:bg-indigo-500 font-semibold py-2 px-4 rounded-lg">Undo Selected Kill</button>`
                ]
            );

            document.getElementById('cancel-btn').onclick = closeModal;
            document.getElementById('confirm-undo-btn').onclick = () => {
                const killIndexToUndo = parseInt(document.getElementById('undo-select').value);
                const killToUndo = gameState.killHistory[killIndexToUndo];

                // Smarter undo logic that does not reset the whole game
                if (!killToUndo) {
                    alert("Could not find the specified kill.");
                    return;
                }
                
                // Fallback for kills made with the old code that don't have the required info
                if (killToUndo.originalKillerTarget === undefined) {
                    alert("This kill was recorded with an older version and cannot be undone precisely. Please reset the game if major changes are needed.");
                    closeModal();
                    return;
                }

                // Create a deep copy of the players to modify
                const newPlayersState = JSON.parse(JSON.stringify(gameState.players));

                const killer = newPlayersState.find(p => p.name === killToUndo.killer);
                const victim = newPlayersState.find(p => p.name === killToUndo.victim);

                if (!killer || !victim) {
                    alert("Could not find the players involved in this kill.");
                    return;
                }

                // 1. Revive the victim
                victim.alive = true;

                // 2. Restore the killer's state to what it was BEFORE the kill
                killer.target = killToUndo.originalKillerTarget;
                killer.word = killToUndo.originalKillerWord;

                // 3. Remove the undone kill from the history array
                const newKillHistory = gameState.killHistory.filter((_, index) => index !== killIndexToUndo);

                // 4. Update the game state in Firestore
                const newState = { ...gameState, players: newPlayersState, killHistory: newKillHistory };
                updateFirestoreState(newState);
                closeModal();
            };
        });

        document.getElementById('set-target-btn').addEventListener('click', () => {
            const alivePlayers = gameState.players.filter(p => p.alive);
            if (alivePlayers.length < 2) {
                alert("You need at least two living players to set a target.");
                return;
            }

            const assassinOptions = alivePlayers.map(p => `<option value="${p.name}">${p.name}</option>`).join('');

            showModal(
                'Set a Target',
                `<div class="space-y-4">
                    <div>
                        <label for="assassin-select" class="block mb-2 text-slate-400">Assassin:</label>
                        <select id="assassin-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg p-2">${assassinOptions}</select>
                    </div>
                    <div>
                        <label for="target-select" class="block mb-2 text-slate-400">Target:</label>
                        <select id="target-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg p-2"></select>
                    </div>
                 </div>`,
                [
                    `<button id="cancel-btn" class="bg-slate-600 hover:bg-slate-500 font-semibold py-2 px-4 rounded-lg">Cancel</button>`,
                    `<button id="confirm-set-target-btn" class="bg-sky-600 hover:bg-sky-500 font-semibold py-2 px-4 rounded-lg">Confirm Target</button>`
                ]
            );

            const assassinSelect = document.getElementById('assassin-select');
            const targetSelect = document.getElementById('target-select');

            function updateTargetOptions() {
                const selectedAssassinName = assassinSelect.value;
                const targetOptions = alivePlayers
                    .filter(p => p.name !== selectedAssassinName)
                    .map(p => `<option value="${p.name}">${p.name}</option>`).join('');
                targetSelect.innerHTML = targetOptions;
            }

            assassinSelect.onchange = updateTargetOptions;
            updateTargetOptions(); // Initial population

            document.getElementById('cancel-btn').onclick = closeModal;
            document.getElementById('confirm-set-target-btn').onclick = () => {
                const assassinName = assassinSelect.value;
                const targetName = targetSelect.value;

                if (!assassinName || !targetName) {
                    alert("Please select both an assassin and a target.");
                    return;
                }

                const newPlayersState = JSON.parse(JSON.stringify(gameState.players));
                const assassin = newPlayersState.find(p => p.name === assassinName);
                
                assassin.target = targetName;
                assassin.word = getWordList()[Math.floor(Math.random() * getWordList().length)];

                const newState = { ...gameState, players: newPlayersState };
                updateFirestoreState(newState);
                closeModal();
            };
        });

        // --- UTILITY FUNCTIONS ---

        function getInitialGameState() {
            const playerNames = [
                'João', 'Cyrus', 'Ali', 'Adriani', 'Skyler', 'Andy J', 'Keiko', 'Daniel',
                'Grace', 'Alethea', 'Josie', 'Amanda', 'Doruk Ege', 'Colette', 'Srinivas', 'JJ',
                'Avery', 'Alexander', 'Sophie', 'Amy', 'Thanh', 'Jessica', 'Audrey', 'Ashvant',
                'Isaac', 'Jonathan', 'Annabel', 'Tara', 'Rio', 'Allison', 'Lucy', 'Jason',
                'Brian', 'Andy S', 'Christina', 'Amelie', 'Kevin', 'Sophia', 'Gavin', 'Lisa'
            ];
            
            return {
                players: playerNames.map(name => ({
                    name: name,
                    target: null,
                    word: null,
                    alive: true
                })),
                killHistory: [],
                gameStarted: false,
                version: 2, // add version to track schema changes
                bracket: currentBracket // track which bracket this is
            };
        }
        
        async function loadWordList() {
            try {
                const response = await fetch('4000-most-common-english-words-csv.csv');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvContent = await response.text();
                
                const lines = csvContent.split(/\r?\n/);
                const words = [];
                
                for (let i = 501; i <= 3001 && i < lines.length; i++) {
                    const word = lines[i].replace(/\r/g, '').trim();
                    if (word) {
                        words.push(word);
                    }
                }
                commonWords = words;
                console.log(`Successfully loaded ${commonWords.length} words from CSV.`);
            } catch (error) {
                console.warn('Could not load CSV file. Using fallback word list.', error);
                commonWords = [
                    'doctor', 'wall', 'patient', 'worker', 'news', 'test', 'movie', 'certain',
                    'north', 'love', 'personal', 'open', 'support', 'simply', 'third',
                    'technology', 'catch', 'step', 'baby', 'computer', 'type', 'attention',
                    'draw', 'film', 'republican', 'tree', 'source', 'red', 'nearly',
                    'organization', 'choose', 'cause', 'hair', 'century', 'evidence', 'window',
                    'difficult', 'listen', 'soon', 'culture', 'billion', 'chance', 'brother',
                    'energy', 'period', 'course', 'summer', 'realize', 'hundred', 'available',
                    'plant', 'likely', 'opportunity', 'term', 'chair', 'protect', 'parent',
                    'interview', 'yesterday', 'sell', 'fire', 'particularly', 'forget', 'cold'
                ];
            }
        }

        function getWordList() {
            return commonWords;
        }

        // --- START THE APP ---
        main();

    </script>
</body>
</html>