<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verbal Assassins - Multiplayer</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for better aesthetics in dark mode */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b;
        }
        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
        /* Simple animation for elements fading in */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-200 antialiased">

    <div id="app" class="container mx-auto p-4 md:p-8 max-w-7xl">

        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-extrabold bg-gradient-to-r from-rose-400 via-fuchsia-500 to-indigo-500 bg-clip-text text-transparent pb-2">
                Verbal Assassins
            </h1>
            <p class="text-slate-400">A real-time multiplayer assassination game for our group.</p>
            <div id="user-info" class="mt-4 text-xs text-slate-500 bg-slate-800 rounded-md p-2 inline-block">
                Connecting...
            </div>
        </header>

        <!-- Loading State -->
        <div id="loading" class="text-center py-10">
            <p class="text-lg text-slate-400">Loading Game State...</p>
        </div>

        <!-- Game Content (hidden until loaded) -->
        <main id="game-content" class="hidden">
            <!-- Controls -->
            <div id="controls" class="flex flex-wrap justify-center gap-3 mb-8 fade-in">
                <button id="shuffle-btn" class="bg-green-600 hover:bg-green-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">üîÄ Shuffle Cycle</button>
                <button id="set-target-btn" class="bg-sky-600 hover:bg-sky-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">üéØ Set Target</button>
                <button id="kill-btn" class="bg-rose-600 hover:bg-rose-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">üíÄ Record Kill</button>
                <button id="undo-kill-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">‚Ü©Ô∏è Undo Kill</button>
                <button id="word-btn" class="bg-amber-500 hover:bg-amber-400 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">üé≤ New Word</button>
                <button id="backup-btn" class="bg-purple-600 hover:bg-purple-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">üíæ Save Backup</button>
                <button id="restore-btn" class="bg-teal-600 hover:bg-teal-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">üìÇ Restore Backup</button>
                <button id="reset-btn" class="bg-slate-600 hover:bg-slate-500 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105">üîÑ Reset Game</button>
            </div>
            
            <!-- Stats -->
            <div class="grid grid-cols-1 sm:grid-cols-4 gap-4 mb-8 fade-in">
                <div class="bg-slate-800 p-4 rounded-xl text-center shadow-lg"><div id="players-alive" class="text-3xl font-bold text-green-400">0</div><div class="text-slate-400">Main Bracket</div></div>
                <div class="bg-slate-800 p-4 rounded-xl text-center shadow-lg"><div id="players-losers" class="text-3xl font-bold text-amber-400">0</div><div class="text-slate-400">Losers Bracket</div></div>
                <div class="bg-slate-800 p-4 rounded-xl text-center shadow-lg"><div id="players-dead" class="text-3xl font-bold text-rose-400">0</div><div class="text-slate-400">Eliminated</div></div>
                <div class="bg-slate-800 p-4 rounded-xl text-center shadow-lg"><div id="total-kills" class="text-3xl font-bold text-sky-400">0</div><div class="text-slate-400">Total Kills</div></div>
            </div>

            <!-- Last save info -->
            <div id="last-save-info" class="text-center mb-4 text-sm text-slate-500"></div>

            <!-- Main Grid -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Players Section -->
                <div class="lg:col-span-2 space-y-6">
                    <!-- Main Bracket -->
                    <div class="bg-slate-800 p-6 rounded-xl shadow-lg fade-in">
                        <div class="flex items-center justify-between mb-4">
                            <h2 class="text-2xl font-bold text-sky-400">Main Bracket</h2>
                            <span class="text-sm text-slate-400">Winners stay here</span>
                        </div>
                        <div id="main-bracket-list" class="space-y-3"></div>
                    </div>
                    
                    <!-- Losers Bracket -->
                    <div class="bg-slate-800 p-6 rounded-xl shadow-lg fade-in">
                        <div class="flex items-center justify-between mb-4">
                            <h2 class="text-2xl font-bold text-amber-400">Losers Bracket</h2>
                            <span class="text-sm text-slate-400">Second chance zone</span>
                        </div>
                        <div id="losers-bracket-list" class="space-y-3"></div>
                        <button id="shuffle-losers-btn" class="mt-4 bg-amber-600 hover:bg-amber-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-all duration-150 ease-in-out hover:scale-105 text-sm">üîÄ Shuffle Losers</button>
                    </div>
                    
                    <!-- Eliminated -->
                    <div class="bg-slate-800 p-6 rounded-xl shadow-lg fade-in">
                        <h2 class="text-xl font-bold mb-4 text-rose-400">Eliminated (Out Completely)</h2>
                        <div id="eliminated-list" class="space-y-3"></div>
                    </div>
                </div>
                
                <!-- Kill History Section -->
                <div class="bg-slate-800 p-6 rounded-xl shadow-lg fade-in">
                    <h2 class="text-2xl font-bold mb-4 text-rose-400">Kill History</h2>
                    <div id="kill-history" class="space-y-3 max-h-[80vh] overflow-y-auto pr-2"></div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modals -->
    <div id="modal-container" class="fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center p-4 hidden">
        <div id="modal-content" class="bg-slate-800 rounded-xl shadow-2xl p-6 w-full max-w-md fade-in">
            <!-- Modal content will be injected here -->
        </div>
    </div>
    
    <!-- Firebase SDKs -->
    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, getDoc, updateDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL VARIABLES & CONFIG ---
        const appId = 'default-verbal-assassins';

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCKPxc3X1-_6qBgEKiyVkoAivGsyShZnMk",
            authDomain: "sumacva-8fbcf.firebaseapp.com",
            projectId: "sumacva-8fbcf",
            storageBucket: "sumacva-8fbcf.firebasestorage.app",
            messagingSenderId: "437614442481",
            appId: "1:437614442481:web:f090082af7324702083650"
        };

        let app, db, auth;
        let userId = null;
        let gameUnsubscribe = null;
        let gameState = {};
        let commonWords = [];

        const loadingEl = document.getElementById('loading');
        const gameContentEl = document.getElementById('game-content');
        const userInfoEl = document.getElementById('user-info');
        const modalContainer = document.getElementById('modal-container');
        const modalContent = document.getElementById('modal-content');
        const lastSaveInfo = document.getElementById('last-save-info');

        // --- INITIALIZATION ---

        async function main() {
            await loadWordList(); 

            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        userInfoEl.innerHTML = `Your User ID: <span class="font-mono text-sky-400">${userId}</span>`;
                        connectToGame();
                    } else {
                        userId = null;
                        userInfoEl.textContent = "Not signed in.";
                        if (gameUnsubscribe) gameUnsubscribe();
                    }
                });

                await signInAnonymously(auth);
            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                loadingEl.innerHTML = `<p class="text-lg text-red-400">Error: Could not connect to the game service.</p><p class="text-sm text-slate-500">${error.message}</p>`;
            }
        }
        
        // --- FIRESTORE REAL-TIME CONNECTION ---

        async function connectToGame() {
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, "verbal-assassins-game-specific");

            try {
                // first, check if document exists to avoid accidental resets
                const docSnap = await getDoc(gameDocRef);
                
                if (!docSnap.exists()) {
                    // instead of auto-creating, ask the user
                    loadingEl.innerHTML = `
                        <p class="text-lg text-amber-400 mb-4">No game found!</p>
                        <p class="text-slate-400 mb-4">Would you like to start a new game?</p>
                        <button id="create-new-game" class="bg-green-600 hover:bg-green-500 text-white font-semibold py-2 px-5 rounded-lg">Create New Game</button>
                    `;
                    
                    document.getElementById('create-new-game').addEventListener('click', async () => {
                        const initialState = getInitialGameState();
                        await setDoc(gameDocRef, initialState);
                        location.reload(); // reload to connect properly
                    });
                    return;
                }

                // now set up real-time listener
                gameUnsubscribe = onSnapshot(gameDocRef, (docSnap) => {
                    loadingEl.classList.add('hidden');
                    gameContentEl.classList.remove('hidden');

                    if (docSnap.exists()) {
                        gameState = docSnap.data();
                        // migrate old games to new format
                        if (!gameState.version || gameState.version < 3) {
                            migrateGameState();
                        }
                        updateDisplay();
                        
                        // show last update time if available
                        if (gameState.lastUpdated?.toDate) {
                            const date = gameState.lastUpdated.toDate();
                            lastSaveInfo.textContent = `Last update: ${date.toLocaleString()}`;
                        }
                    }
                }, (error) => {
                    console.error("Error listening to game state:", error);
                    loadingEl.innerHTML = `<p class="text-red-400">Error: Lost connection to the game.</p><p class="text-sm text-slate-500">${error.message}</p>`;
                });

            } catch (error) {
                console.error("Error connecting to game:", error);
                loadingEl.innerHTML = `<p class="text-red-400">Error: Could not connect to game.</p><p class="text-sm text-slate-500">${error.message}</p>`;
            }
        }

        // --- MIGRATION FUNCTION ---
        
        function migrateGameState() {
            console.log('Migrating game state to version 3...');
            // add bracket field to all players if it doesn't exist
            const newPlayersState = gameState.players.map(player => ({
                ...player,
                bracket: player.bracket || 'main' // default everyone to main bracket
            }));
            
            const newState = {
                ...gameState,
                players: newPlayersState,
                version: 3,
                losersBracketStarted: false
            };
            
            updateFirestoreState(newState);
        }

        // --- UI UPDATE FUNCTION ---

        function updateDisplay() {
            if (!gameState) return;

            // get players by bracket
            const mainBracketPlayers = gameState.players ? gameState.players.filter(p => p.alive && p.bracket === 'main') : [];
            const losersBracketPlayers = gameState.players ? gameState.players.filter(p => p.alive && p.bracket === 'losers') : [];
            const eliminatedPlayers = gameState.players ? gameState.players.filter(p => !p.alive) : [];
            
            document.getElementById('players-alive').textContent = mainBracketPlayers.length;
            document.getElementById('players-losers').textContent = losersBracketPlayers.length;
            document.getElementById('players-dead').textContent = eliminatedPlayers.length;
            document.getElementById('total-kills').textContent = gameState.killHistory?.length || 0;

            // display main bracket
            const mainBracketList = document.getElementById('main-bracket-list');
            mainBracketList.innerHTML = '';
            if (mainBracketPlayers.length > 0) {
                const sortedMainPlayers = [...mainBracketPlayers].sort((a, b) => a.name.localeCompare(b.name));
                sortedMainPlayers.forEach(player => {
                    mainBracketList.appendChild(createPlayerCard(player, 'main'));
                });
            } else {
                mainBracketList.innerHTML = `<p class="text-slate-500 text-center py-4">No players in main bracket.</p>`;
            }

            // display losers bracket
            const losersBracketList = document.getElementById('losers-bracket-list');
            losersBracketList.innerHTML = '';
            if (losersBracketPlayers.length > 0) {
                const sortedLosersPlayers = [...losersBracketPlayers].sort((a, b) => a.name.localeCompare(b.name));
                sortedLosersPlayers.forEach(player => {
                    losersBracketList.appendChild(createPlayerCard(player, 'losers'));
                });
            } else {
                losersBracketList.innerHTML = `<p class="text-slate-500 text-center py-4">No players in losers bracket yet.</p>`;
            }

            // display eliminated
            const eliminatedList = document.getElementById('eliminated-list');
            eliminatedList.innerHTML = '';
            if (eliminatedPlayers.length > 0) {
                eliminatedPlayers.forEach(player => {
                    const playerCard = document.createElement('div');
                    playerCard.className = `p-4 rounded-lg bg-slate-800/50 opacity-50`;
                    playerCard.innerHTML = `
                        <div class="font-bold text-lg text-slate-500 line-through">${player.name}</div>
                        <div class="text-sm text-slate-600">Eliminated from ${player.bracket || 'main'} bracket</div>
                    `;
                    eliminatedList.appendChild(playerCard);
                });
            } else {
                eliminatedList.innerHTML = `<p class="text-slate-500 text-center py-4">No eliminated players.</p>`;
            }

            // kill history
            const killHistoryEl = document.getElementById('kill-history');
            killHistoryEl.innerHTML = '';
            if (gameState.killHistory && gameState.killHistory.length > 0) {
                [...gameState.killHistory].reverse().forEach(kill => {
                    const killEntry = document.createElement('div');
                    killEntry.className = 'bg-slate-700/50 p-3 rounded-lg';
                    const bracketBadge = kill.bracket ? `<span class="text-xs px-2 py-1 rounded-full ${kill.bracket === 'losers' ? 'bg-amber-600/30 text-amber-400' : 'bg-sky-600/30 text-sky-400'}">${kill.bracket}</span>` : '';
                    killEntry.innerHTML = `
                        <div>
                            <span class="font-bold text-rose-400">${kill.killer}</span> eliminated <span class="font-bold text-slate-400">${kill.victim}</span>
                            ${bracketBadge}
                        </div>
                        <div class="text-xs text-slate-500 mt-1">Word: <span class="font-mono">${kill.word}</span> at ${kill.timestamp}</div>
                    `;
                    killHistoryEl.appendChild(killEntry);
                });
            } else {
                killHistoryEl.innerHTML = `<p class="text-slate-500 text-center py-4">No kills recorded yet.</p>`;
            }
        }

        function createPlayerCard(player, bracket) {
            const playerCard = document.createElement('div');
            const bracketColor = bracket === 'losers' ? 'bg-amber-900/30 border-amber-700/50' : 'bg-slate-700';
            playerCard.className = `p-4 rounded-lg grid grid-cols-1 md:grid-cols-3 gap-4 items-center transition-all duration-300 ${bracketColor} ${bracket === 'losers' ? 'border' : ''}`;
            
            const targetInfo = player.target || 'N/A';
            const wordInfo = player.word || 'N/A';

            playerCard.innerHTML = `
                <div class="font-bold text-lg text-white">${player.name}</div>
                <div class="text-slate-400">Target: <span class="font-semibold text-rose-400">${targetInfo}</span></div>
                <div class="text-slate-400">Word: <span class="font-mono bg-slate-600 px-2 py-1 rounded text-amber-300">${wordInfo}</span></div>
            `;
            return playerCard;
        }

        // --- GAME ACTIONS (WRITING TO FIRESTORE) ---

        async function updateFirestoreState(newState) {
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, "verbal-assassins-game-specific");
            try {
                // add timestamp to track when changes happen
                newState.lastUpdated = serverTimestamp();
                newState.lastUpdatedBy = userId;
                
                await setDoc(gameDocRef, newState);
            } catch (error) {
                console.error("Error updating game state:", error);
                alert("Failed to update game state. Please check your connection.");
            }
        }

        // backup functionality
        async function saveBackup() {
            const backupData = {
                ...gameState,
                backupDate: new Date().toISOString(),
                backupBy: userId
            };
            
            // store in browser's local storage with timestamp
            const backupKey = `verbal-assassins-backup-${new Date().getTime()}`;
            localStorage.setItem(backupKey, JSON.stringify(backupData));
            
            // also store reference to latest backup
            localStorage.setItem('verbal-assassins-latest-backup', backupKey);
            
            // keep only last 5 backups to save space
            const allKeys = Object.keys(localStorage).filter(k => k.startsWith('verbal-assassins-backup-'));
            if (allKeys.length > 5) {
                allKeys.sort();
                const toRemove = allKeys.slice(0, allKeys.length - 5);
                toRemove.forEach(key => localStorage.removeItem(key));
            }
            
            alert(`Backup saved! (${new Date().toLocaleTimeString()})`);
        }

        async function showRestoreOptions() {
            const allBackups = Object.keys(localStorage)
                .filter(k => k.startsWith('verbal-assassins-backup-'))
                .sort()
                .reverse();
            
            if (allBackups.length === 0) {
                alert("No backups found in your browser.");
                return;
            }
            
            const options = allBackups.map(key => {
                const backup = JSON.parse(localStorage.getItem(key));
                const date = new Date(backup.backupDate);
                const mainCount = backup.players?.filter(p => p.alive && p.bracket === 'main').length || 0;
                const losersCount = backup.players?.filter(p => p.alive && p.bracket === 'losers').length || 0;
                const killCount = backup.killHistory?.length || 0;
                return `<option value="${key}">${date.toLocaleString()} - Main: ${mainCount}, Losers: ${losersCount}, ${killCount} kills</option>`;
            }).join('');
            
            showModal(
                'Restore from Backup',
                `<label for="backup-select" class="block mb-2 text-slate-400">Select a backup to restore:</label>
                 <select id="backup-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg p-2 mb-4">${options}</select>
                 <p class="text-amber-400 text-sm">‚ö†Ô∏è This will overwrite the current game state!</p>`,
                [
                    `<button id="cancel-btn" class="bg-slate-600 hover:bg-slate-500 font-semibold py-2 px-4 rounded-lg">Cancel</button>`,
                    `<button id="confirm-restore-btn" class="bg-teal-600 hover:bg-teal-500 font-semibold py-2 px-4 rounded-lg">Restore</button>`
                ]
            );

            document.getElementById('cancel-btn').onclick = closeModal;
            document.getElementById('confirm-restore-btn').onclick = async () => {
                const selectedKey = document.getElementById('backup-select').value;
                const backupData = JSON.parse(localStorage.getItem(selectedKey));
                
                // remove backup metadata before restoring
                delete backupData.backupDate;
                delete backupData.backupBy;
                
                await updateFirestoreState(backupData);
                closeModal();
                alert("Game restored from backup!");
            };
        }

        // add event listeners for new buttons
        document.getElementById('backup-btn').addEventListener('click', saveBackup);
        document.getElementById('restore-btn').addEventListener('click', showRestoreOptions);
        
        document.getElementById('shuffle-btn').addEventListener('click', () => {
            // only shuffle main bracket players
            let activePlayers = gameState.players.filter(p => p.alive && p.bracket === 'main');
            if (activePlayers.length < 2) {
                alert("You need at least 2 living players in the main bracket to shuffle.");
                return;
            }

            let shuffled = [...activePlayers].sort(() => 0.5 - Math.random());
            const words = getWordList();
            if (words.length === 0) {
                alert("Word list is not available. Cannot shuffle.");
                return;
            }
            const newPlayersState = JSON.parse(JSON.stringify(gameState.players));

            shuffled.forEach((shuffledPlayer, i) => {
                const target = shuffled[(i + 1) % shuffled.length];
                const playerInState = newPlayersState.find(p => p.name === shuffledPlayer.name);
                if (playerInState) {
                    playerInState.target = target.name;
                    playerInState.word = words[Math.floor(Math.random() * words.length)];
                }
            });
            
            const newState = { ...gameState, players: newPlayersState, gameStarted: true };
            updateFirestoreState(newState);
        });

        // shuffle losers bracket
        document.getElementById('shuffle-losers-btn').addEventListener('click', () => {
            let losersPlayers = gameState.players.filter(p => p.alive && p.bracket === 'losers');
            if (losersPlayers.length < 2) {
                alert("You need at least 2 players in the losers bracket to shuffle.");
                return;
            }

            let shuffled = [...losersPlayers].sort(() => 0.5 - Math.random());
            const words = getWordList();
            const newPlayersState = JSON.parse(JSON.stringify(gameState.players));

            shuffled.forEach((shuffledPlayer, i) => {
                const target = shuffled[(i + 1) % shuffled.length];
                const playerInState = newPlayersState.find(p => p.name === shuffledPlayer.name);
                if (playerInState) {
                    playerInState.target = target.name;
                    playerInState.word = words[Math.floor(Math.random() * words.length)];
                }
            });
            
            const newState = { ...gameState, players: newPlayersState, losersBracketStarted: true };
            updateFirestoreState(newState);
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            showModal(
                'Confirm Reset',
                '<p>Are you sure you want to reset the game? This will restore the original player list and clear all kills and targets.</p><p class="text-amber-400 text-sm mt-2">üí° Tip: Save a backup first!</p>',
                [
                    `<button id="cancel-btn" class="bg-slate-600 hover:bg-slate-500 font-semibold py-2 px-4 rounded-lg">Cancel</button>`,
                    `<button id="confirm-reset-btn" class="bg-rose-600 hover:bg-rose-500 font-semibold py-2 px-4 rounded-lg">Confirm Reset</button>`
                ]
            );

            document.getElementById('cancel-btn').onclick = closeModal;
            document.getElementById('confirm-reset-btn').onclick = () => {
                const newState = getInitialGameState();
                updateFirestoreState(newState);
                closeModal();
            };
        });

        // --- MODAL HANDLING ---
        
        function showModal(title, content, buttons) {
            modalContent.innerHTML = `
                <h3 class="text-xl font-bold mb-4 text-sky-300">${title}</h3>
                <div class="mb-6">${content}</div>
                <div class="flex justify-end gap-3">
                    ${buttons.join('')}
                </div>
            `;
            modalContainer.classList.remove('hidden');
        }

        function closeModal() {
            modalContainer.classList.add('hidden');
        }
        
        modalContainer.addEventListener('click', (e) => {
            if (e.target === modalContainer) {
                closeModal();
            }
        });

        document.getElementById('kill-btn').addEventListener('click', () => {
            const alivePlayers = gameState.players.filter(p => p.alive && p.target);
            if (alivePlayers.length < 2) {
                alert("Not enough players with targets are alive. Try shuffling first.");
                return;
            }
            
            // group by bracket for better organization
            const mainBracketOptions = alivePlayers.filter(p => p.bracket === 'main')
                .map(p => `<option value="${p.name}">[MAIN] ${p.name} ‚Üí ${p.target}</option>`).join('');
            const losersBracketOptions = alivePlayers.filter(p => p.bracket === 'losers')
                .map(p => `<option value="${p.name}">[LOSERS] ${p.name} ‚Üí ${p.target}</option>`).join('');
            
            const allOptions = mainBracketOptions + losersBracketOptions;
            
            showModal(
                'Record a Kill',
                `<label for="killer-select" class="block mb-2 text-slate-400">Who got the kill?</label>
                 <select id="killer-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg p-2 mb-4">${allOptions}</select>
                 <div class="mb-4">
                    <input type="checkbox" id="send-to-losers" class="mr-2" checked>
                    <label for="send-to-losers" class="text-slate-400">Send victim to losers bracket (uncheck to eliminate completely)</label>
                 </div>`,
                [
                    `<button id="cancel-btn" class="bg-slate-600 hover:bg-slate-500 font-semibold py-2 px-4 rounded-lg">Cancel</button>`,
                    `<button id="confirm-kill-btn" class="bg-rose-600 hover:bg-rose-500 font-semibold py-2 px-4 rounded-lg">Confirm</button>`
                ]
            );

            document.getElementById('cancel-btn').onclick = closeModal;
            document.getElementById('confirm-kill-btn').onclick = () => {
                const newPlayersState = JSON.parse(JSON.stringify(gameState.players));
                const killerName = document.getElementById('killer-select').value;
                const sendToLosers = document.getElementById('send-to-losers').checked;
                const killer = newPlayersState.find(p => p.name === killerName);
                const victim = newPlayersState.find(p => p.name === killer.target);
                
                if (!killer || !victim) {
                    alert('Error finding killer or victim. State may have changed.');
                    return;
                }

                // Store the killer's state BEFORE the kill for undo purposes
                const originalKillerTarget = killer.target;
                const originalKillerWord = killer.word;

                // decide victim's fate
                if (sendToLosers && victim.bracket === 'main') {
                    // send to losers bracket instead of killing
                    victim.bracket = 'losers';
                    victim.target = null; // clear target, will need to be reshuffled
                    victim.word = null;
                } else {
                    // eliminate completely (either from losers bracket or if unchecked)
                    victim.alive = false;
                }

                // killer inherits target
                killer.target = victim.target;
                killer.word = getWordList()[Math.floor(Math.random() * getWordList().length)];

                // Add the kill to history with bracket info
                const newKillHistory = [...(gameState.killHistory || []), {
                    killer: killer.name,
                    victim: victim.name,
                    word: killer.word,
                    timestamp: new Date().toLocaleTimeString(),
                    originalKillerTarget: originalKillerTarget,
                    originalKillerWord: originalKillerWord,
                    bracket: killer.bracket,
                    sentToLosers: sendToLosers && victim.bracket === 'main'
                }];

                const newState = { ...gameState, players: newPlayersState, killHistory: newKillHistory };
                updateFirestoreState(newState);
                closeModal();
            };
        });
        
        document.getElementById('word-btn').addEventListener('click', () => {
            const alivePlayers = gameState.players.filter(p => p.alive);
            const options = alivePlayers.map(p => `<option value="${p.name}">[${p.bracket.toUpperCase()}] ${p.name}</option>`).join('');
            
            showModal(
                'Assign New Word',
                `<label for="word-player-select" class="block mb-2 text-slate-400">Select Player:</label>
                 <select id="word-player-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg p-2">${options}</select>`,
                [
                    `<button id="cancel-btn" class="bg-slate-600 hover:bg-slate-500 font-semibold py-2 px-4 rounded-lg">Cancel</button>`,
                    `<button id="assign-word-btn" class="bg-amber-500 hover:bg-amber-400 font-semibold py-2 px-4 rounded-lg">Assign</button>`
                ]
            );

            document.getElementById('cancel-btn').onclick = closeModal;
            document.getElementById('assign-word-btn').onclick = () => {
                const newPlayersState = JSON.parse(JSON.stringify(gameState.players));
                const playerName = document.getElementById('word-player-select').value;
                const player = newPlayersState.find(p => p.name === playerName);
                player.word = getWordList()[Math.floor(Math.random() * getWordList().length)];
                
                const newState = { ...gameState, players: newPlayersState };
                updateFirestoreState(newState);
                closeModal();
            };
        });

        document.getElementById('undo-kill-btn').addEventListener('click', () => {
            if (!gameState.killHistory || gameState.killHistory.length === 0) {
                alert("There are no kills to undo.");
                return;
            }
            
            const options = gameState.killHistory.map((kill, index) => {
                const bracketInfo = kill.bracket ? `[${kill.bracket.toUpperCase()}]` : '';
                const losersInfo = kill.sentToLosers ? ' (‚Üí losers)' : '';
                return `<option value="${index}">${bracketInfo} ${kill.killer} ‚Üí ${kill.victim}${losersInfo} (${kill.timestamp})</option>`;
            }).join('');

            showModal(
                'Undo a Kill',
                `<label for="undo-select" class="block mb-2 text-slate-400">Select kill to remove:</label>
                 <select id="undo-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg p-2">${options}</select>`,
                [
                    `<button id="cancel-btn" class="bg-slate-600 hover:bg-slate-500 font-semibold py-2 px-4 rounded-lg">Cancel</button>`,
                    `<button id="confirm-undo-btn" class="bg-indigo-600 hover:bg-indigo-500 font-semibold py-2 px-4 rounded-lg">Undo Selected Kill</button>`
                ]
            );

            document.getElementById('cancel-btn').onclick = closeModal;
            document.getElementById('confirm-undo-btn').onclick = () => {
                const killIndexToUndo = parseInt(document.getElementById('undo-select').value);
                const killToUndo = gameState.killHistory[killIndexToUndo];

                if (!killToUndo) {
                    alert("Could not find the specified kill.");
                    return;
                }
                
                // Fallback for kills made with the old code that don't have the required info
                if (killToUndo.originalKillerTarget === undefined) {
                    alert("This kill was recorded with an older version and cannot be undone precisely. Please reset the game if major changes are needed.");
                    closeModal();
                    return;
                }

                // Create a deep copy of the players to modify
                const newPlayersState = JSON.parse(JSON.stringify(gameState.players));

                const killer = newPlayersState.find(p => p.name === killToUndo.killer);
                const victim = newPlayersState.find(p => p.name === killToUndo.victim);

                if (!killer || !victim) {
                    alert("Could not find the players involved in this kill.");
                    return;
                }

                // undo the kill based on what happened
                if (killToUndo.sentToLosers) {
                    // victim was sent to losers, bring them back to main
                    victim.bracket = 'main';
                    victim.alive = true;
                } else {
                    // victim was eliminated, revive them to their original bracket
                    victim.alive = true;
                }

                // restore killer's original state
                killer.target = killToUndo.originalKillerTarget;
                killer.word = killToUndo.originalKillerWord;

                // remove from kill history
                const newKillHistory = gameState.killHistory.filter((_, index) => index !== killIndexToUndo);

                const newState = { ...gameState, players: newPlayersState, killHistory: newKillHistory };
                updateFirestoreState(newState);
                closeModal();
            };
        });

        document.getElementById('set-target-btn').addEventListener('click', () => {
            const alivePlayers = gameState.players.filter(p => p.alive);
            if (alivePlayers.length < 2) {
                alert("You need at least two living players to set a target.");
                return;
            }

            const assassinOptions = alivePlayers.map(p => `<option value="${p.name}">[${p.bracket.toUpperCase()}] ${p.name}</option>`).join('');

            showModal(
                'Set a Target',
                `<div class="space-y-4">
                    <div>
                        <label for="assassin-select" class="block mb-2 text-slate-400">Assassin:</label>
                        <select id="assassin-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg p-2">${assassinOptions}</select>
                    </div>
                    <div>
                        <label for="target-select" class="block mb-2 text-slate-400">Target:</label>
                        <select id="target-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg p-2"></select>
                    </div>
                    <p class="text-xs text-amber-400">‚ö†Ô∏è Players can only target others in the same bracket</p>
                 </div>`,
                [
                    `<button id="cancel-btn" class="bg-slate-600 hover:bg-slate-500 font-semibold py-2 px-4 rounded-lg">Cancel</button>`,
                    `<button id="confirm-set-target-btn" class="bg-sky-600 hover:bg-sky-500 font-semibold py-2 px-4 rounded-lg">Confirm Target</button>`
                ]
            );

            const assassinSelect = document.getElementById('assassin-select');
            const targetSelect = document.getElementById('target-select');

            function updateTargetOptions() {
                const selectedAssassinName = assassinSelect.value;
                const selectedAssassin = alivePlayers.find(p => p.name === selectedAssassinName);
                // only show targets in same bracket
                const targetOptions = alivePlayers
                    .filter(p => p.name !== selectedAssassinName && p.bracket === selectedAssassin.bracket)
                    .map(p => `<option value="${p.name}">${p.name}</option>`).join('');
                targetSelect.innerHTML = targetOptions || '<option value="">No valid targets in same bracket</option>';
            }

            assassinSelect.onchange = updateTargetOptions;
            updateTargetOptions(); // Initial population

            document.getElementById('cancel-btn').onclick = closeModal;
            document.getElementById('confirm-set-target-btn').onclick = () => {
                const assassinName = assassinSelect.value;
                const targetName = targetSelect.value;

                if (!assassinName || !targetName) {
                    alert("Please select both an assassin and a target.");
                    return;
                }

                const newPlayersState = JSON.parse(JSON.stringify(gameState.players));
                const assassin = newPlayersState.find(p => p.name === assassinName);
                
                assassin.target = targetName;
                assassin.word = getWordList()[Math.floor(Math.random() * getWordList().length)];

                const newState = { ...gameState, players: newPlayersState };
                updateFirestoreState(newState);
                closeModal();
            };
        });

        // --- UTILITY FUNCTIONS ---

        function getInitialGameState() {
            const playerNames = [
                'Jo√£o', 'Cyrus', 'Ali', 'Adriani', 'Skyler', 'Andy J', 'Keiko', 'Daniel',
                'Grace', 'Alethea', 'Josie', 'Amanda', 'Doruk Ege', 'Colette', 'Srinivas', 'JJ',
                'Avery', 'Alexander', 'Sophie', 'Amy', 'Thanh', 'Jessica', 'Audrey', 'Ashvant',
                'Isaac', 'Jonathan', 'Annabel', 'Tara', 'Rio', 'Allison', 'Lucy', 'Jason',
                'Brian', 'Andy S', 'Christina', 'Amelie', 'Kevin', 'Sophia', 'Gavin', 'Lisa'
            ];
            
            return {
                players: playerNames.map(name => ({
                    name: name,
                    target: null,
                    word: null,
                    alive: true,
                    bracket: 'main' // everyone starts in main bracket
                })),
                killHistory: [],
                gameStarted: false,
                losersBracketStarted: false,
                version: 3, // bump version for losers bracket support
            };
        }
        
        async function loadWordList() {
            try {
                const response = await fetch('4000-most-common-english-words-csv.csv');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvContent = await response.text();
                
                const lines = csvContent.split(/\r?\n/);
                const words = [];
                
                for (let i = 501; i <= 3001 && i < lines.length; i++) {
                    const word = lines[i].replace(/\r/g, '').trim();
                    if (word) {
                        words.push(word);
                    }
                }
                commonWords = words;
                console.log(`Successfully loaded ${commonWords.length} words from CSV.`);
            } catch (error) {
                console.warn('Could not load CSV file. Using fallback word list.', error);
                commonWords = [
                    'doctor', 'wall', 'patient', 'worker', 'news', 'test', 'movie', 'certain',
                    'north', 'love', 'personal', 'open', 'support', 'simply', 'third',
                    'technology', 'catch', 'step', 'baby', 'computer', 'type', 'attention',
                    'draw', 'film', 'republican', 'tree', 'source', 'red', 'nearly',
                    'organization', 'choose', 'cause', 'hair', 'century', 'evidence', 'window',
                    'difficult', 'listen', 'soon', 'culture', 'billion', 'chance', 'brother',
                    'energy', 'period', 'course', 'summer', 'realize', 'hundred', 'available',
                    'plant', 'likely', 'opportunity', 'term', 'chair', 'protect', 'parent',
                    'interview', 'yesterday', 'sell', 'fire', 'particularly', 'forget', 'cold'
                ];
            }
        }

        function getWordList() {
            return commonWords;
        }

        // --- START THE APP ---
        main();

    </script>
</body>
</html>